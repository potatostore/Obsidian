모든 문법이 담긴 것이 아닌, 내가 모르거나 꼭 알아야 하는 부분만 축약적으로 담긴 노트이다.

# [[1. 전처리기]]

.c와 .h, 즉 소스코드와 헤더파일은 정의를 하냐, 선언을 하냐에 따라 차이를 나눌 수 있다.

컴퓨터를 지칭하게 되면 실행, 소위 말하는 연산을 하는 부분을 담당하는 cpu를 가르킨다. 

우리가 .c, .java, .py 등 다양한 언어로 코드를 작성하게 되면 하나의 파일이 생성이 되는데, 이를       #소스코드 라고 한다.

소스코드를 컴퓨터에게 인식시키고, 연산하게 만드는 과정을 커치기 위해서는 우선적으로 소스코드를 #머신코드 로 바꾸어야 하는데, 이를 #컴파일러 , #링커  가 담당하여 바꾼다.

컴파일러는 소스코드를 .obj같은 #목적파일 로 컴파일한 후, 목적파일을 링커가 목적파일을 .exe같은 #실행파일 로 링킹을 해주면 완성이 된다.

이때 의문점이 있는데, vs c++ compiler 같은 컴파일러들이 어떻게 단독으로 .c파일을 .exe파일로 변환이 가능한가이다. 사실 vs c++ compiler 같은 컴파일러들은 컴파일러 뿐만 아니라 링커를 포함한 
#도구체인 이다. 따라서 단순히 컴파일러만 존재하는 것이 아닌 속에 링커가 포함되어 있다 라고 볼 수 있다.

# [[2. 자료형]]

- 상수 : ASCII, UNI 등의 부호체제가 존재함
	- 리터럴 : 숫자
	- 심볼릭 : 문자
	- #부호체계 : 일정 수의 나열을 문자로 인식하는 약속 (ASCII, UNI etc...), 0x3c를 해당하는 문자로 바꾸어 입출력함.
- 변수 : 우리가 아는 변수들 (char, int, long, long long int, float, double ...)

*변수사용시 주의점*
- 메모리 관리 주의 : 각 자료형의 사용되는 메모리를 정확하게 이해하고, 특히 문자열같은 경우 마지막에 '\n'을 위해 한자리가 소모된다는 점을 망각하면 memory overflow가 발생.

# [[3.I/O]]

- 입출력을 정확하게 이해하기 위해 컴퓨터용어 및 구성을 이해해야함.
	- Computer
		- #H/W : 다양한 컴퓨터 장치들이 구성을 이룸
		- #S/W : 크게 두 개의 층이 존재하는데, User, Kernel층이 존재함
			- User : 개인이 컨트롤할 수 있는 영역으로 process, debugger, file등이 존재함.
				- #Debbuger : 다른 process에 접근할 수 있는 유일한 process로 이를 통해 해킹과 같은 
				- #Process : 특정 기능을 수행하기 위해 메모리 등의 컴퓨터 자원을 할당 받아 독립적으로 실행되는 단위
				- #Thread : Process내에서 특정 기능을 수행하기 위한 실행 단위
			- kernel : S/W 조작을 위해 장치에 신호를 주거나 받는 영역.
		- 1개의 os가 여러 process를 조작함 -> multi-tasking
		- 1개의 process가 여러 thread를 조작함 -> multi-threading

<span style="color:rgb(0, 176, 80)">High level</span>  <span style="color:rgb(255, 0, 0)">User</span>   Process, Thread, Debugger, File

--- 
		   <span style="color:rgb(255, 0, 0)">Kernel</span>    Driver, Os, I/O

--- 
<span style="color:rgb(0, 176, 80)">Low level </span>  <span style="color:rgb(255, 0, 0)">H/W</span>   Device, monitor etc...


I/O는 기본적으로 장치로부터 입력을 받거나, 장치에 전기신호를 통해 출력을 하는 형태이다. 따라서 H/W에 직접적으로 간여할 수 있는 Kernel 층에 I/O가 해당된다고 볼 수 있다. 
또한 H/W에 신호를 주고 받을 수 있는 Kernel과는 달리 User는 Kernel,H/W에 직접적으로 신호를 줄 수 없다. 따라서 모든 장치(Devices)가 추상화된 file을 통해 kernel에 접근하게 되는데, 이때 우리가 User층에서 출력문을 실행하면, file이 변경되어 모니터로 확인이 되기에 I/O가 마치 User층에서 실행되는 것처럼 보이기에 혼동된다고 볼 수 있다. 

file을 작성하기 위해 정보나 규칙을 정해놓는데, 이를 Protocol이라고 한다.
그리고 이 Protocol에 맞추어 일일이 작성하는 것을 지양하고자 getchar(), putchar()와 같은 I/O함수들이 탄생했다고 볼 수 있다.

- #Buffer : Memory의 일종으로 데이터를 일시적으로 저장하는 공간으로 생각하면 쉽다. buffer은 user층, kernel층 모두에 해당하는데 이는 프로세스, file, os등 모든 user, kernel층이 일시적으로 갖을 수 있다. 
  각각의 역할에 따라 buffer의 쓰임새가 다른데, 만약 데이터 송수신이 발생했을 때, 수신속도보다 송신속도가 빠를경우, 송신이 일시적으로 매끄럽게 이루어지지 않아 데이터가 마치 끊기는 듯한 현상이 발생하는데, 이를 ==Buffering==이라고 한다.

Buffer의 개념에 대해 짚고 넘어간 이유는 c언어의 getchar(), scanf(), gets()등의 input fucntion들은 키보드를 통한 하드웨어 인터럽트가 발생을 하면, 이 데이터들이 file의 read buffer에 일시적으로 쌓이게 되는데, 이때문에 c언어의 I/O 일부를 ==Buffered I/O==라고 한다.

- Buffer가 쌓이는 과정
	1. H/W에 하드웨어 인터럽트 발생
	2. kernel층의 console이 이벤트 신호를 받아 console을 추상화한 file에 신호를 넘김
	3. file은 이를 read buffer에 쌓음 (user층 프로세스가 데이터를 읽을 준비가 되었을 때까지   보관)

- 궁금증
	1. thread는 유저층이고, core는 하드웨어층인데, core를 어떻게 thread가 간접적으로 밑에서 도와줄까?
	2. buffer overflaw가 어떤식으로 발생하고, 왜 위험할까?
	3. buffer overflaw가 큰 보안문제를 야기할 수 있다면, java와 같이 가비지 컬렉터를 일부분 적용하면 예방할 수 있지 않을까?


1. 이것은 우리가 직관적으로 봤을 때 코어 바로 밑에 쓰레드가 존재하여 도와주는 것처럼 보이지만, 실상은 다음과 같다.
   
	1. 입력, 출력 등 컴퓨터가 연산해야하는 행위가 발생한다.
	2. 하드웨어층에서 ==하드웨어 인터럽트==를 통해 커널로 신호를 보낸다.
	3. 커널층에서 이를 받고, 인터럽트를 처리하여 유저층에 있는 프로세스에 전달을 해야하는데 이 과정을 ==커널의 인터럽트 처리 루틴== 이라고 한다.
	4. 인터럽트 처리 루틴 이후 프로세스에 이벤트를 넘겨주면, 프로세스가 이에 대해 판단을 하여 자원 및 연산 요청을 커널층으로 보낸다. 이를 ==시스템 호출 (System Call)==이라고 한다.
	5. 커널에 존재하는 ==스케줄러(scheduler)==가 이를 받아 해당 프로세스의 스레드가 어떤 코어에서 실행할지 결정한다. 
	- 결론적으로 위 과정을 통해 프로세스 내에 존재하는 스레드가 코어에 할당받아 연산을 실행하는 것이므로 코어 밑에 스레드가 작동을 한다고 볼 수 있는 것이다.
	  
2. buffer overflaw를 정의하면 buffer로 사용되기 위해 할당된 메모리를 초과하여 발생하는 현상이다. 
   c언어 같은 경우 변수를 선언하게 되면 그에 따라 메모리가 할당이 되는데, 이 메모리에 초과되는 입력이 발생하는 경우 read buffer에 들어가지 못한 데이터들은 다른 메모리 영역에 쌓이게 된다. 
   해당 메모리 영역이 프로세스가 사용하지 않은 영역이면 다행이지만, 그렇지 않은 경우 프로세스 실행 과정에서 큰 오류가 발생할 수 있다. 
   또한 보안상 문제가 생길 수 있는데, 메모리의 특정 위치에 악성코드를 삽입하는 ==버퍼 오버플로 공격==에 피해입을 수 있다. 
   그렇기에 사람들이 gets()를 있어서 사용하면 안되는 함수로 뽑는데 fgets()와 같이 입력하는 메모리의 양을 조절할 수 있는 함수를 사용하고, 문자열의 경우 마지막에 '\n'을 위해 한 자리를 비워놔야 한다는 점을 명시하면서 코드를 짜야 한다.
   
4. 가비지 컬렉터는 c/c++의 특징을 훼손시킬 수 있는데, 특히 메모리를 사용자가 컨트롤 할 수 있는 언어가 가비지 컬렉터를 사용하면 다른 언어에 비해 이점이 전혀 존재하지 않으므로, 사용하지 않는다. 
   하지만 원할 경우 필요한 곳에 라이브러리를 한정적으로 추가할 수 있다.

어느정도의 기본적인 컴퓨터과학 지식을 이해했으니 I/O에 대해 배워보자

- Input : scanf(), getchar(), gets()와 같은 함수들을 통해 입력을 받을 수 있는데, 위에서 말했던 것처럼 메모리를 직접 관리하기에 gets()와 같은 입력은 ==Memory overflow==가 발생하는 치명적인 사고가 발생할 수 있다. 
  따라서 직접 buffer에서 필요한 만큼의 입력데이터를 받아올 수 있는 fgets(), gets_s()와 같은 함수를 쓰는 것이 바람직하다

- output : printf()

c++
- c와의 차이점
	- 객체지향이다. 객체지향을 비유적으로 이해하자면 서양철학과 유사한데, 플라톤의 이데아 사상처럼 개념과 구현이 나뉘어진 코드, 즉 자료형과 변수를 각각 개념과 구현에 빗대어 표현할 수 있다. 이때 객체지향은 절차지향과 달리 개념과 구현이 각각 따로 분리되어 있다는 점을 비유적으로 표현할 수 있다. c언어에서 개념, 즉 자료형을 직접 구현하기 위해서는 구조체를 사용하는 제한적인 방법밖에 없지만, c++에서 자료형을 구현하기 위해서 class, 구조체 등등 다양한 방법을 통해 만들어낼 수 있다는 것이 핵심이다.
- 참조자
	- 포인터와 가장 큰 차이점은 구동방식이다. 참조자는 변수에 다른 명칭을 붙이는 반면, 포인터는 변수의 주소값을 가르킨다. 이 구동방식 때문에 참조자는 참조한 변수 이외의 다른 변수를 참조할 수 없는 반면, 포인터는 주소를 새로 초기화 하면 되기에 다른 변수를 가르킬 수 있다.

| **특징**       | **참조자 (Reference)**      | **포인터 (Pointer)**   |
| ------------ | ------------------------ | ------------------- |
| **선언 시 초기화** | 선언 시 반드시 초기화해야 함         | 초기화 없이 선언 가능        |
| **NULL 가능성** | 참조자는 NULL을 가리킬 수 없음      | 포인터는 NULL을 가리킬 수 있음 |
| **대상 변경**    | 초기화 후 다른 대상을 참조할 수 없음    | 다른 대상을 가리키도록 변경 가능  |
| **사용법**      | 변수처럼 사용                  | * 및 & 연산자로 간접 참조 필요 |
| **메모리 사용**   | 메모리 주소를 저장하지 않음          | 메모리 주소를 저장          |
| **레퍼런스 연산**  | 암시적(ref = 20; 자동으로 a 수정) | 명시적(*ptr = 20;)\    |
즉 NULL값을 가르키거나 동적 메모리 할당이 필요한 경우를 제외하고 참조자를 매개변수에 사용하는 것이 유리하다.

<span style="color:rgb(255, 0, 0)">??vector와 같은 동적 메모리 할당을 자연스럽게 요구하는 변수들을 매개변수로 사용할 때 굳이 포인터를 사용하지 않고 참조자를 통해 쉽게 변동이 가능한데, 굳이 동적메모리 할당을 할 때 포인터를 통해 이루어져야 할까?</span>

- 후행반환형
	- 함수 혹은 메서드의 반환형을 명확시 하거나, 반환형이 여러방향으로 존재할 경우 오버로딩을 피하기 위해 사용된다. 코드를 예제로 이해해보자.

```c++
int add(int a, int b){return a+b;}
double add(double a, int b){return a+b;}
double add(int a, double b){return a+b;}
double add(double a, double b){return a+b;}
```

이런식으로 코드를 짤 때, 반환형이 여러 개이거나, 매개변수의 자료형이 여러가지 존재할 경우, 오버로딩을 피할 수 없다. 하지만 후행반환형을 사용하게 되면

```c++
auto add(auto a, auto b) -> decltype(a+b){return a+b;}
```

이런식으로 사용이 된다. 보통 위와 같이 매개변수의 자료형이 다양할 경우, auto를 사용하는 것보단

```c++
template <typename T1, typename T2>
auto add(T1 a, T2 b) -> decltype(a+b){return a+b;}
```

로 template 함수를 통해 

- static

- 