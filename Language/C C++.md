모든 문법이 담긴 것이 아닌, 내가 모르거나 꼭 알아야 하는 부분만 축약적으로 담긴 노트이다.

시작하기에 앞서 본문에서 나온 메모리는 모두 가상메모리(Virtual Memory)를 가르키는 것이다.
(참고)[[Virtual Memory]]

# C
## 1. 전처리기

.c와 .h, 즉 소스코드와 헤더파일은 정의를 하냐, 선언을 하냐에 따라 차이를 나눌 수 있다.

컴퓨터를 지칭하게 되면 실행, 소위 말하는 연산을 하는 부분을 담당하는 cpu를 가르킨다. 

우리가 .c, .java, .py 등 다양한 언어로 코드를 작성하게 되면 하나의 파일이 생성이 되는데, 이를       #소스코드 라고 한다.

소스코드를 컴퓨터에게 인식시키고, 연산하게 만드는 과정을 커치기 위해서는 우선적으로 소스코드를 #머신코드 로 바꾸어야 하는데, 이를 #컴파일러 , #링커  가 담당하여 바꾼다.

컴파일러는 소스코드를 .obj같은 #목적파일 로 컴파일한 후, 목적파일을 링커가 목적파일을 .exe같은 #실행파일 로 링킹을 해주면 완성이 된다.

이때 의문점이 있는데, vs c++ compiler 같은 컴파일러들이 어떻게 단독으로 .c파일을 .exe파일로 변환이 가능한가이다. 사실 vs c++ compiler 같은 컴파일러들은 컴파일러 뿐만 아니라 링커를 포함한 
#도구체인 이다. 따라서 단순히 컴파일러만 존재하는 것이 아닌 속에 링커가 포함되어 있다 라고 볼 수 있다.

---
## 2. 자료형

- 상수 : ASCII, UNI 등의 부호체제가 존재함
	- 리터럴 : 숫자
	- 심볼릭 : 문자
	- #부호체계 : 일정 수의 나열을 문자로 인식하는 약속 (ASCII, UNI etc...), 0x3c를 해당하는 문자로 바꾸어 입출력함.
- 변수 : 우리가 아는 변수들 (char, int, long, long long int, float, double ...)

*변수사용시 주의점*
- 메모리 관리 주의 : 각 자료형의 사용되는 메모리를 정확하게 이해하고, 특히 문자열같은 경우 마지막에 '\n'을 위해 한자리가 소모된다는 점을 망각하면 memory overflow가 발생.

- 같은 문자열 상수에 대한 포인터는 같은 주소값을 갖는다.

```c
const char *str1 = "Hello World";
const char *str2 = "Hello World";

//&str1 == &str2
```

<span style="color:rgb(255, 0, 0)">컴파일러</span>가 정적 메모리를 할당할 때 같은 문자열 상수로 초기화된 변수에 대해 메모리를 2번 소비할 필요가 없다고 판단하여 같은 메모리 주소를 갖게 한다.

---
## 3. I/O

- 입출력을 정확하게 이해하기 위해 컴퓨터용어 및 구성을 이해해야 한다.
	- Computer
		- #H/W : 다양한 컴퓨터 장치들이 구성을 이룸
		- #S/W : 크게 두 개의 층이 존재하는데, User, Kernel층이 존재함
			- User : 개인이 컨트롤할 수 있는 영역으로 process, debugger, file등이 존재함.
				- #Debbuger : 다른 process에 접근할 수 있는 유일한 process로 이를 통해 해킹과 같은 
				- #Process : 특정 기능을 수행하기 위해 메모리 등의 컴퓨터 자원을 할당 받아 독립적으로 실행되는 단위
				- #Thread : Process내에서 특정 기능을 수행하기 위한 실행 단위
			- kernel : S/W 조작을 위해 장치에 신호를 주거나 받는 영역.
		- 1개의 os가 여러 process를 조작함 -> multi-tasking
		- 1개의 process가 여러 thread를 조작함 -> multi-threading

<span style="color:rgb(0, 176, 80)">High level</span>  <span style="color:rgb(255, 0, 0)">User</span>   Process, Thread, Debugger, File

--- 
		   <span style="color:rgb(255, 0, 0)">Kernel</span>    Driver, Os, I/O

--- 
<span style="color:rgb(0, 176, 80)">Low level </span>  <span style="color:rgb(255, 0, 0)">H/W</span>   Device, monitor etc...


I/O는 기본적으로 장치로부터 입력을 받거나, 장치에 전기신호를 통해 출력을 하는 형태이다. 따라서 H/W에 직접적으로 간여할 수 있는 Kernel 층에 I/O가 해당된다고 볼 수 있다. 
또한 H/W에 신호를 주고 받을 수 있는 Kernel과는 달리 User는 Kernel,H/W에 직접적으로 신호를 줄 수 없다. 따라서 모든 장치(Devices)가 추상화된 file을 통해 kernel에 접근해야 한다. 출력문을 작성하면

file을 작성하기 위해 정보나 규칙을 정해놓는데, 이를 Protocol이라고 한다.
그리고 이 Protocol에 맞추어 일일이 작성하는 것을 지양하고자 getchar(), putchar()와 같은 I/O함수들이 탄생했다고 볼 수 있다.

- #Buffer : Memory의 일종으로 데이터를 일시적으로 저장하는 공간으로 생각하면 쉽다. buffer은 user층, kernel층 모두에 해당하는데 이는 프로세스, file, os등 모든 user, kernel층이 일시적으로 갖을 수 있다. 
  각각의 역할에 따라 buffer의 쓰임새가 다른데, 만약 데이터 송수신이 발생했을 때, 수신속도보다 송신속도가 빠를경우, 송신이 일시적으로 매끄럽게 이루어지지 않아 데이터가 마치 끊기는 듯한 현상이 발생하는데, 이를 ==Buffering==이라고 한다.

Buffer의 개념에 대해 짚고 넘어간 이유는 c언어의 getchar(), scanf(), gets()등의 input fucntion들은 키보드를 통한 하드웨어 인터럽트가 발생을 하면, 이 데이터들이 file의 read buffer에 일시적으로 쌓이게 되는데, 이때문에 c언어의 I/O 일부를 ==Buffered I/O==라고 한다.

- Buffer가 쌓이는 과정
	1. H/W에 하드웨어 인터럽트 발생
	2. kernel층의 console이 이벤트 신호를 받아 console을 추상화한 file에 신호를 넘김
	3. file은 이를 read buffer에 쌓음 (user층 프로세스가 데이터를 읽을 준비가 되었을 때까지   보관)

- 궁금증
	1. thread는 유저층이고, core는 하드웨어층인데, core를 어떻게 thread가 간접적으로 밑에서 도와줄까?
	2. buffer overflaw가 어떤식으로 발생하고, 왜 위험할까?
	3. buffer overflaw가 큰 보안문제를 야기할 수 있다면, java와 같이 가비지 컬렉터를 일부분 적용하면 예방할 수 있지 않을까?


1. 이것은 우리가 직관적으로 봤을 때 코어 바로 밑에 쓰레드가 존재하여 도와주는 것처럼 보이지만, 실상은 다음과 같다.
   
	1. 입력, 출력 등 컴퓨터가 연산해야하는 행위가 발생한다.
	2. 하드웨어층에서 ==하드웨어 인터럽트==를 통해 커널로 신호를 보낸다.
	3. 커널층에서 이를 받고, 인터럽트를 처리하여 유저층에 있는 프로세스에 전달을 해야하는데 이 과정을 ==커널의 인터럽트 처리 루틴== 이라고 한다.
	4. 인터럽트 처리 루틴 이후 프로세스에 이벤트를 넘겨주면, 프로세스가 이에 대해 판단을 하여 자원 및 연산 요청을 커널층으로 보낸다. 이를 ==시스템 호출 (System Call)==이라고 한다.
	5. 커널에 존재하는 ==스케줄러(scheduler)==가 이를 받아 해당 프로세스의 스레드가 어떤 코어에서 실행할지 결정한다. 
	- 결론적으로 위 과정을 통해 프로세스 내에 존재하는 스레드가 코어에 할당받아 연산을 실행하는 것이므로 코어 밑에 스레드가 작동을 한다고 볼 수 있는 것이다.
	  
2. buffer overflaw를 정의하면 buffer로 사용되기 위해 할당된 메모리를 초과하여 발생하는 현상이다. 
   c언어 같은 경우 변수를 선언하게 되면 그에 따라 메모리가 할당이 되는데, 이 메모리에 초과되는 입력이 발생하는 경우 read buffer에 들어가지 못한 데이터들은 다른 메모리 영역에 쌓이게 된다. 
   해당 메모리 영역이 프로세스가 사용하지 않은 영역이면 다행이지만, 그렇지 않은 경우 프로세스 실행 과정에서 큰 오류가 발생할 수 있다. 
   또한 보안상 문제가 생길 수 있는데, 메모리의 특정 위치에 악성코드를 삽입하는 ==버퍼 오버플로 공격==에 피해입을 수 있다. 
   그렇기에 사람들이 gets()를 있어서 사용하면 안되는 함수로 뽑는데 fgets()와 같이 입력하는 메모리의 양을 조절할 수 있는 함수를 사용하고, 문자열의 경우 마지막에 '\n'을 위해 한 자리를 비워놔야 한다는 점을 명시하면서 코드를 짜야 한다.
   
4. 가비지 컬렉터는 c/c++의 특징을 훼손시킬 수 있는데, 특히 메모리를 사용자가 컨트롤 할 수 있는 언어가 가비지 컬렉터를 사용하면 다른 언어에 비해 이점이 전혀 존재하지 않으므로, 사용하지 않는다. 
   하지만 원할 경우 필요한 곳에 라이브러리를 한정적으로 추가할 수 있다.

어느정도의 기본적인 컴퓨터과학 지식을 이해했으니 I/O에 대해 배워보자

- Input : scanf(), getchar(), gets()와 같은 함수들을 통해 입력을 받을 수 있는데, 위에서 말했던 것처럼 메모리를 직접 관리하기에 gets()와 같은 입력은 ==Memory overflow==가 발생하는 치명적인 사고가 발생할 수 있다. 
  따라서 직접 buffer에서 필요한 만큼의 입력데이터를 받아올 수 있는 fgets(), gets_s()와 같은 함수를 쓰는 것이 바람직하다

- output : printf()

#### scanf / scanf_s의 차이
- 

---

## 4. 강제형변환

- 형변환에는 두 가지 경우가 있다.
	1. 새로운 변수에 기존에 존재하던 값을 넣어야 할 때.
	2. 기존 변수의 형을 변환시킬때.

항상 메모리를 할당하고, 자료형을 지정하기에 강제형변환 진행시 부동소수점과 같은 값들이 손실될 가능성을 배제할 수 없다.

---
## 5. 연산자

연산자의 종류는 매우 다양하다.

지정연산자(* , &), 구조체도트연산자(.) 등등 다양한 연산자가 존재한다.

그 중 특이하게 cpu가 실행하지 않고, 컴파일러가 실행하는 연산자가 존재하는데 sizeof()연산자이다.

연산자는 *short circuit*에 따라 좌에서 우로 연산이 이루어진다. 이때 필요치 않는 연산(a && b || c에서 a&&b가 1이 나오면 자동으로 1출력)이 발생하면 연산을 하지 않고 값을 반환한다. 따라서 쉬운(빠른) 연산이나 자주 적중(참이 될)할 확률이 높은 연산이 먼저 오면 비교적 적은 연산이 쇼요될 가능성이 높아진다. 

#### sizeof()
	sizeof()연산자 같은 경우 앞서 말한 것처럼 cpu를 사용하는 연산자가 아닌 컴파일러를 통해 값을 도출하기에 많이 사용해도 과부하가 걸리지 않는다. 따라서 사용가능한 모든 곳에 사용하면 좋은 연산자라고 볼 수 있다.
	
	특히 컴파일러가 실행한다는 점에서 wchar_t자료형과 같이 컴파일러(utf-16, utf-32)에 따라 자료형의 메모리 값이 바뀌는 자료형들의 크기를 상수화할때 사용하면 매우 좋은 코드가 작성된다고 할 수 있다.

	추가로 sizeof()와 같은 연산자는 자료형을 매개변수로 활용하기에 type promotion(형 승격)와 같이 자료형이 변하더라도 유동적으로 원하는 값을 도출할 수 있다.

#### 비교연산자
	비교연산자의 주의점은 실수부분이다. 부동소수점으로 인한 오차때문에 비교연산자가 정상적으로 작동하지 않을 가능성이 높아 되도록 실수를 가지고 비교연산자를 실행해서는 안된다. 추가로 switch-case문 같은 경우 비교연산자(==)를 통해 case문을 판별하기에 case뒤에 항상 정수가 와야한다.

#### 삼항조건연산자

	c, c++에만 있는 연산자로 조건문이 간단한 경우 사용하여 코드를 간결하게 나타낼 수 있다.

```c++ title='삼항조건연산자'
#include <iostream>

int main(void){
	int n;
	std::result = "";
	
	std::cin >> n;

	//일반 조건문
	if(n >= 0) {
		result = "양수";
	}
	else{
		result = "음수"
	}


	//삼항조건연산자
	result = (n >= 0) ? "양수" : "음수";

	return 0;
}
```

위 예시처럼 4줄의 코드를 한 줄로 줄여 코드의 가독성을 높일 수 있다.

위 코드를 디스어셈블리 창으로 확인하면 위 조건문이 삼항조건연산자보다 조금 더 적은 코드로 이루어져 있다는 것을 확인할 수 있는데, 이는 큰 차이가 아니므로 상관 없다.

---

## 6. 조건문

if, switch와 같은 조건문은 다룰 것이 많지 않아 넘어간다.

다중조건문을 사용하게 되면 가장 큰 문제점은 가독성이다. 
가독성을 해치는 코드를 작성하면 팀프로젝트에서 의사소통이 원활하게 이루어지지 않을 가능성이 높다.
또한 성능도 크게 저하된다. 따라서 다중조건문을 최대한 피하도록 만들어야 하는데 그 중 하나가 *Lookup-table*이다.

#### Lookup-table

조건문의 구간에 맞추어 배열을 만들고, 결과값을 미리 배열에 넣어 조건문 없이 값을 반환받는 배열이다.

```c++ title='Lookup-table'
#include <iostream>
using namespace std;

int main(void){
	int result[10] = {
		10,20,30,40,50,60,70,80,90,100
	}

	int score;
	cin >> score;

	//반올림
	cout << result[score/10];
	returm 0;
}
```

메모리를 아주 조금 더 쓰고 가독성과 성능을 가져간 좋은 코드가 완성이 된다.

이처럼 다중조건문을 필요하는 상황이 오면, 최대한 다른 방법으로 코드를 유도하고, 불가능하면 최후의 선택으로 사용하도록 노력하자.

*goto문은 예외처리, 오류출력 이외에 사용하는 경우가 존재하면 안되므로 따로 넣지 않았습니다.*

---
## 7. 반복문

for, while, do-while문이 존재하고, 제어문으로 break, continue가 있는데, continue는 가급적 사용하지 않는 것이 좋다.

---

## 8. 배열

*참고사항* : [[Array]]

배열은 동일한 자료형의 연속된 집합체라는 정의를 갖고 있다.

이 말은 배열 원소들은 모두 같은 자료형을 갖고, 메모리에 할당되었을때 붙어있어야 한다.

그렇기에 배열의 다음 원소로 이동하기 위해 '주솟값' + sizeof(자료형)을 하면 다음 원소로 이동이 되며, 이 원리는 배열의 인덱스의 밑바탕이 된다.

배열의 인덱스는 붙어있는 원소들의 번호를 매기는 것이다.

이는 배열내 특정 원소를 불러올때 매우 유용한데

```c++
int arr[5];

arr = arr[0] = arr + 0 = &arr
//3번째 원소 
arr[3] == arr + 3
```

와 같이 다양한 방식으로 배열을 호출할 수 있고, 특정 원소를 통해 알 수 있다는 것이다.

사실 위 코드에는 함정이 있는데 arr[3] == arr+3이 될 수 없다.

arr을 호출하게 되면 기본적으로 0번째 원소를 불러오는 것이 아닌 arr의 주솟값(0번째 주소)를 불러오기 때문이다.

배열은 처음 선언시 크기를 정해야 하기에 고정길이라고 볼 수 있다.
이와 반대로 char형 배열을 문자열이라고 하는데, 이는 가변길이이다. 즉 크기가 마음대로 변할 수 있다는 것이다.
특히 문자열의 끝은 '\0'으로 끝나고, 이는 1바이트를 차지한다. 즉 이 말은 내가 "hello"라는 워드를 배열에 넣는다고 가정하면 5byte의 메모리를 사용하는 것이 아니라 6byte의 메모리를 사용하는 것이다. 
정해진 크기에 문자열을 집어 넣을 때, 위와 비슷한 실수로 인해 배열의 크기보다 큰 데이터를 배열에 넣으면 데이터가 안들어가거나 일부 데이터의 손실이 발생하는데 이를 *overflow*라고 한다.

2차원 배열이 논리적으로 데카르트 좌표계처럼 2차원적으로 나타내는데, 사실 메모리는 선형적 구조이기 때문에 나열된 직선상으로 표현이 된다. 그렇다면 이런 표현도 가능하지 않을까?

```c++
int arr[3][4];
for(int i=0;i<12;i++){
	arr[0][i] = i;
}
```

놀랍게도 위 코드는 정상적으로 실행이 된다.

원리는 간단한데 메모리는 선형구조를 이루어져 있기에

| arr 0, 1 | arr 0,2 | arr 0,3 | arr0,4 | arr1,0 | ... | ... |
| -------- | ------- | ------- | ------ | ------ | --- | --- |

와 같은 구조의 메모리가 형성되는 것이다.

---
## 9. 함수

함수라는 것은 반복적으로 수행되는 한 가지의 기능을 따로 담아놓은 매개체라고 정의하고 싶다.

[[Clean Code]]에서 나온 것처럼 함수는 항상 한 가지의 기능을 해야하지, 그 이상을 하게 되면 함수로서의 기능을 상실한 것과 같다고 볼 수 있다.

*DRY(don't repeat yourself) : 여려 번 같은 기능을 반복하지 말아라*

함수를 c에 한정된 개념이 아닌 모든 언어가 사용하고, 방법은 다르지만 결론적으로 한 가지의 기능의 반복수행을 위한 개념이기에 통념된다고 생각한다.

그렇기에 모든 프로젝트의 설계는 이 함수를 어떻게 잘 짜냐에 따라서 프로젝트의 성능과 품질이 달라진다고 볼 수 있다.

- 호출자/피호출자 : 함수를 부르는 주체를 호출자, 호출되는 함수는 피호출자로 지정한다.
- 보통 함수를 호출하게 되면 자동적으로 스택 영역을 사용한다. 

인간은 기계에 정보를 입력하거나, 기계가 계산한 정보를 출력받는다. 이는 곧 UI/기능 이 두가지의 영역이 모두 필요하고, 이를 나누기 위해서는 적어도 함수단위로 구분되어야 한다. 

UI(user interface) : 인간과 기계가 상호작용할 수 있도록 연결되는 장치를 뜻하고, 이는 사용자의 입력을 유도하는데 용이하게 상요된다.

기능 : 기능은 실질적으로 기계가 작동하기 위한 코드를 작성하는 곳으로, 사용자의 입력이 있거나, 계산을 통해 사용자에게 출력을 해야하는 경우를 뜻한다.

즉 우리는 한 가지의 기능을 한 함수에 담는다는 원칙을 고수하기 위해, UI/기능을 모두 구현하는 프로그램을 작성하게 되면, 최소 두 개 이상의 함수는 필요하다는 얘기이다.

#### 이벤트 루프

함수를 다루면서 가장 중요한 기능 중 하나라고 생각이 드는데, 이벤트란 사용자가 UI를 통해 메뉴가 화면에 출력되면, 이를 통해 선택을 하는 것을 뜻한다. 이벤트 루프는 이와 같은 이벤트가 반복된다는 것인데, 이벤트 루프가 필요한 경우는 대개 은행업무와 같이 다양한 업무처리를 위한 프로그램을 제작할 때 사용한다.

	system("cls") : 메뉴 출력전 화면을 지운다(clear screen)

#### 원형선언

c/c++과 같은 절차지향언어는 함수를 사용할 때 꼭 메인함수 앞에 정의가 있어야 사용할 수 있다. 하지만 메인함수 앞에 선언하게 되면 메인함수를 찾는 것도 어렵고, 가독성을 해치는 이유로 메인함수 후에 기능을 구현할 수 있는데, 이때 메인함수 앞에 함수가 존재한다는 것을 알리는 것이 원형선언이다.


## 10. 포인터

포인터는 c언어의 꽃인 부분이다. 메모리를 사용자가 직접적으로 접근함으로서 c언어의 특징을 살리는 코드를 작성할 수 있다. 

#### byte order : big-endian, little-endian

byte order에 대해 알기 위해 endian이 무엇인지부터 정의를 해야한다.

- endian : 컴퓨터 메모리와 같이 1차원 공간에 여러개의 연속된 대상을 나열하는 방법

전에 배열을 설명하면서 데이터는 1차원 공간에 끊임없이 나열되어 있는 형태로 저장이 된다라고 언급한바가 있다. 그 중 일부의 공간을 변수에 할당해줬을때, 변수에 초기화된 값을 할당된 공간에 나열하는 방법이 *endian*이 되는 것이다. 

endian은 다양한 종류가 존재하지만, 그 중 포인터와 관련된 endian이 바로 *byte order*이다. 말 그대로 바이트를 나열하는 방법이라고 설명할 수 있다.

흔히 1byte를 한 칸으로 빗대어 설명을 많이 한다. 그렇게 되면 c언어를 기준으로 int형 변수를 선언하면, 4칸짜리 메모리가 할당되는 그림을 상상할 수 있을 것이다. 변수를 어떤 상수로 초기화할 경우, 그 상수는 16진수로 치환이 되고, 이를 4칸에 나누어 저장할 수 있다. 

예를 들어보자

```c++ title='byte order'
100 -> 0x64 -> 00 00 00 64
```

와 같이 4칸에 나뉘는데, 이를 4byte(4칸)에 저장하는 방식이 따로 있다.

- little endian: 가장 작은 바이트를 메모리의 낮은 주소에 저장하는 방식
- big endian: 가장 큰 바이트를 메모리의 낮은 주소에 저장하는 방식
- middle endian: 위 두 방식을 모두 지원하거나, 지원하지 않는 방식

```c++
little endian : 00 00 00 64 -> 64 00 00 00 
big endian : 00 00 00 64 -> 00 00 00 64
```

- 왜 1byte에 16진수 2개의 수만 들어갈까?

1byte = 8bit, 1bit는 2진수로 한자리수만 나타낼 수 있는데, 두 칸으로 나뉘에서 한 칸당 2^4 - 1= 15 즉 0~15까지 나타낼 수 있는 16진수 한칸이 들어간다. 즉 1byte에는 16진수가 두 칸 들어갈 메모리가 나온다.

- 왜 little, big endian으로 나누어서 메모리에 저장을 할까? 한 가지의 방법으로 저장하면 되지 않을까?

1. 하드웨어 설계 철학의 차이 : 초기 컴퓨터 설계할 때 제조사마다 구조가 달랐다.
2. cpu 아키텍처 차이 : 데이터 처리시 더 유리한 방식으로 채택(네트워크 프로토콜 - bit, intel - little)
3. 초기 컴퓨터는 독립적인 컴퓨터 환경으로 인하여 표준화 필요성을 느끼지 못함.

- 통일하지 않는 이유 

1. 하위 호환성 : 기존 설계 유지의 중요성
2. 각 분야별 표준화의 차이
3. 시스템 효율성 차이
#### ASLR

Address Space Layout Randomization : 메모리 해킹을 방지하기 위해 매번 변수의 메모리 주소를 랜덤으로 변경하는 것

#### 포인터

c언어의 가장 큰 장점은 다른 언어와 달리 운영체제와 메모리를 직접적으로 컨트롤하여 퍼포먼스를 최대한 끌어올리는 것이다. 포인터는 c언어의 특징이 담겨있는 문법이라고 볼 수 있다.

변수를 이루는 3가지의 요소는 다음과 같다.

4. 이름(변수명)
5. 정보(상수)
6. 메모리 주소

대부분 변수를 피연산자로 호출하게 되면 *2. 정보(상수)* 가 연산에 참여하지만, 앞서 말한 것처럼 메모리를 직접적으로 컨트롤 하기 위해서 *3. 메모리 주소*를 생각해야 한다. 메모리 주소가 피연산자로서 참여하는 단항연산자는 바로 *주소 번지 연산자(&)* 이다. 이는 현재 변수에 할당된 메모리의 주소를 반환해주는 연산자이다. 

포인터 변수는 메모리를 저장하는 전용 변수이다. 메모리 주소를 int형 변수에 저장해서 현재의 포인터처럼 사용하면 되지 않나라고 생각할 수 있지만, 

7. 데이터 의미의 명확성 : 변수가 int형 10진수 상수를 담고 있는지, 메모리 주소를 담고 있는지 구별하기 힘듬
8. 데이터 크기 : 32-bit 운영체제는 4바이트, 64-bit 운영체제는 8바이트를 메모리 주소로 표현하고, 이는 고정적인 int형 4바이트와 맞지 않을 가능성도 존재하기 때문

등 다양한 이유로 인해 포인터라는 새로운 개념을 도입하게 되었다.

여기서 개념하나만 더 익히고 들어가자.

지정이라는 단어는 일정크기의 메모리의 데이터 값을 해석하는 방식, 즉 자료형을 정해주는 것이고, 이는 2가지 방법으로 나뉜다.

	직접지정 : 변수명을 통해 메모리의 자료형을 결정해주는 행위
	간접지정 : 변수에 할당된 메모리의 주소를 통해 자료형을 결정해주는 행위

직접지정은 대입연산자(=) 등을 사용하고, 간접지정은 포인터(간접지정 연산자)를 통해 사용된다.

즉 여태 변수명을 통해 변수를 호출하는 형태는 전부 직접지정을 통해 연산을 진행한것이고, 지금부터 사용하게 될 포인터를 통해 연산을 진행하면 간접지정을 통해 연산을 하는 것이다.

- 포인터는 왜 사용할까?

포인터는 생각해보면 대안이 존재할 것 같은 연산자이기에 포인터를 왜 사용해야 하나 의문이 든다.

9. 동적 메모리 할당 : 정적 메모리에만 변수명을 선언할 수 있기에 동적 메모리를 다루기 위해 포인터 개념 도입
10. 메모리 공유 : 함수 호출과 같이 같은 메모리를 작업하는 환경에서 필요

```c++ title="pointer"
#include <stdio.h>

int main(void){
	int x = 10;

	//포인터는 앞서 말한것처럼 변수의 주소값을 통해 간접적으로 가르킴
	int *pointer = &x;
	printf("%d", pointer);

	return 0;
}
```

포지션 브레이크를 걸고 값을 확인해보면 
pointer변수 메모리 내부에는 x변수의 주소값이 들어가 있다. 
ptr이 가르키는 곳을 따라가면 x의 값이 저장되어 있다.

#### 메모리

- stack(1MB) : 스코프 내부 코드
- heap(32-bit기준 1.7GB) : 자유 영역 
- PE image
	- text : code
	- data : RW(읽기, 쓰기 전용 파일) -> 전역변수, R -> 문자열 상수

## 11. 최적화

| 용어                                                    | 의미                     | 결과 파일                   |
| ----------------------------------------------------- | ---------------------- | ----------------------- |
| **[어셈블리화](https://ko.wikipedia.org/wiki/어셈블리어)**      | 고수준 언어 → 어셈블리어 변환      | `.s` (어셈블리 파일)          |
| **[어셈블](https://ko.wikipedia.org/wiki/어셈블러)**         | 어셈블리어 → 머신코드(목적 코드) 변환 | `.o` / `.obj` (목적 파일)   |
| **[링킹](https://ko.wikipedia.org/wiki/링커_(소프트웨어))**    | 목적 파일 → 실행 파일 변환       | `.exe` / `.out` (실행 파일) |
| **[컴파일 (좁은 의미)](https://ko.wikipedia.org/wiki/컴파일러)** | C/C++ → 어셈블리어 변환       | `.s` (어셈블리 파일)          |
| **[컴파일 (넓은 의미)](https://ko.wikipedia.org/wiki/컴파일러)** | 실행 파일을 만드는 전체 과정       | `.exe`, `.out`          |
# C++

## 0. c와의 차이점

- 객체지향이다. 객체지향을 비유적으로 이해하자면 서양철학과 유사한데, 플라톤의 이데아 사상처럼 개념과 구현이 나뉘어진 코드, 즉 자료형과 변수를 각각 개념과 구현에 빗대어 표현할 수 있다. 이때 객체지향은 절차지향과 달리 개념과 구현이 각각 따로 분리되어 있다는 점을 비유적으로 표현할 수 있다. c언어에서 개념, 즉 자료형을 직접 구현하기 위해서는 구조체를 사용하는 제한적인 방법밖에 없지만, c++에서 자료형을 구현하기 위해서 class, 구조체 등등 다양한 방법을 통해 만들어낼 수 있다는 것이 핵심이다.
- r-value 참조 : 

*r-value : 표현식 이후에 사라지는 값, 임시변수
l-value : 표현식 이후에도 사라지지 않는 값, 변수*

```c++ title='r-value, l-value'
int main(void){
	int x = 3;// 3->r-value
	const int y = x;
	int z = x+y;// x+y->r-value
	int* p = &x// &x->r-value

	cout << std::string("one");// std::string("one")->r-value
	retur 0;
}

//r-value모두 표현식 이후에 사라지는 임시변수이고, 좌항은 모두 표현식 이후에 메모리가 할당되어 사라지지 않는 변수이므로 l-value이다.
```

---

## 1. function

- default parameter : 함수 매개변수에 디폴트 값을 설정하여 실수인자 설정이 없어도 연산이 가능하게 한다.

```c++ title=default parameter
int functest(int, int = 10);

int main(void){
	std::cout << functest(1);
	return 0;
}

int functest(int a, int b){
	return a + b;
}

//b에 default parameter가 적용되어 main()에서 b의 값을 설정 안해줘도 자동으로 10으로 초기화 된다.
```

우측부터 순차적으로 채워놓아야 에러 없이 가능한데, 맨 우측에 default parameter설정 없이 좌측만 할 경우 위와 같이 main()함수 실행 시 에러가 뜬다.

*google coding style guide에 따르면 위와 같이 에러가 많이 발생할 가능성이 높으므로 사용을 지양한다.*

- overriding / overloading
	- overriding : 재정의를 뜻하며, c++의 장점인 다형성을 추구하는 특성이다.
	- overloading : 다중정의를 뜻하며, 호출자(coller)측에서 혼란을 야기할 수도 있다.

오버라이딩과 오버로딩은 c++이 언어로서 갖는 특징 중 하나인 다형성을 위한 기술이라고 볼 수 있다. 

위와 같은 재정의,다중정의는 어떻게 가능할까?

*Name mangling*이라는 방법에 의해 가능해지는데, 함수 이름(변수)를 선언하게 되면 이를 compiler가 식별하기 위해 본명으로 바꾸는 방식이다. 즉 다같은 함수명을 가져도, 매개변수나 반환값이 다르면 다른 본명을 갖게 된다는 것이다.

c와 달리 *다형성*이 중요한 c++은 얽매이지 않고, 다양한 형태의 코드스타일을 구사하기 위해 위와 같은 기술들이 도입되어 장점의 극대화를 노렸으며, 이는 곧 장점이 되지만, 단점이 되기도 한다.

특히 *모호성*의 탈피를 하나의 과제로 여기는 언어 특성상 유지보수를 위한 코드스타일을 지향할 수 밖에 없는데, 오버라이딩/오버로딩의 남발은 유지보수에 필요한 자원을 증가시킬 수 있기에 신중하게 써야한다.

예를 들어
```c++
int add(int a, int b){
	return a+b;
}

double add(double a, double b){
	return a+b;
}

//위 오버로딩은 coller입장에서 매우 간편해 보이지만,
//1. add호출 시 어떤 add가 호출되는지 짐작되지 않는다.
//2. add(1.5, 2)와 같이 다른 매개변수가 등장할경우 추가적인 오버로딩이 필요하다.
//와 같이 추가적인 유지보수가 필요해 보인다.
```

따라서 위와 같은 유지보수를 줄이고자 등장한 개념이 *함수 템플릿*이다.

- 함수 템플릿(function template) : 매개변수의 틀을 제작하여 실수인자에 따라 변하는 방식
	우선 템플릿은 두 종류로 분류되는데, 함수측면과 클래스 측면이다.

```c++
template <typename T>
T add(T a, T b){
	return a+b;
}
```

위 예시와 같이 템플릿을 사용하게 되면 호출자가 함수를 시행할 때, 실수인자의 자료형에 따라 매개변수의 자료형이 결정되어 위 오버로딩의 문제점을 무마시켜준다는 장점을 준다.

- inline function : c와 동일

- namespace : 변수명, 함수명의 중복을 피하기 위해 소속을 정해주는 개념
	위 재정의, 다중정의를 통해 c++에서는 다형성을 지향하는 언어라는 것을 깨닫고, 이를 통해 일관된 변수명을 가질 수 있다는 것을 알았다. 하지만 템플릿이 나온 이유처럼, 같은 변수명을 갖게 되면 유지보수에 큰 자원이 필요하게 되고, 이를 막기위해 템플릿을 사용해도, 오버로딩/오버라이딩을 꼭 사용해야 하는 경우도 존재한다. 이를 위해 같은 이름이여도 다른 소속을 갖게 해주는 개념이 *namespace*이다.
	
	- 범위지정연산자(::) : 소속을 알려주는 연산자로서 "namespace"::"변수명"과 같은 방식으로 사용된다. 추가로 무소속(전역변수 등)과 같은 경우 ::printf()와 같이 앞에 범위지정연산자만 써주는게 정석이지만, 생략해도 무방하다. (사용하는 것을 권장한다.)
	- using : using선언을 하게 되면 해당 namespace를 범위지정연산자 없이 호출이 가능해진다. 그런데 범위지정연산자 없이 호출을 하게 되면 namespace를 쓰는 이유가 사라진다. 지양하자.



---
## 2. 참조자
- 포인터와 가장 큰 차이점은 구동방식이다. 참조자는 변수에 다른 명칭을 붙이는 반면, 포인터는 변수의 주소값을 가르킨다. 이 구동방식 때문에 참조자는 참조한 변수 이외의 다른 변수를 참조할 수 없는 반면, 포인터는 주소를 새로 초기화 하면 되기에 다른 변수를 가르킬 수 있다.

| **특징**       | **참조자 (Reference)**      | **포인터 (Pointer)**   |
| ------------ | ------------------------ | ------------------- |
| **선언 시 초기화** | 선언 시 반드시 초기화해야 함         | 초기화 없이 선언 가능        |
| **NULL 가능성** | 참조자는 NULL을 가리킬 수 없음      | 포인터는 NULL을 가리킬 수 있음 |
| **대상 변경**    | 초기화 후 다른 대상을 참조할 수 없음    | 다른 대상을 가리키도록 변경 가능  |
| **사용법**      | 변수처럼 사용                  | * 및 & 연산자로 간접 참조 필요 |
| **메모리 사용**   | 메모리 주소를 저장하지 않음          | 메모리 주소를 저장          |
| **레퍼런스 연산**  | 암시적(ref = 20; 자동으로 a 수정) | 명시적(*ptr = 20;)\    |
즉 NULL값을 가르키거나 동적 메모리 할당이 필요한 경우를 제외하고 참조자를 매개변수에 사용하는 것이 유리하다.

<span style="color:rgb(255, 0, 0)">??vector와 같은 동적 메모리 할당을 자연스럽게 요구하는 변수들을 매개변수로 사용할 때 굳이 포인터를 사용하지 않고 참조자를 통해 쉽게 변동이 가능한데, 굳이 동적메모리 할당을 할 때 포인터를 통해 이루어져야 할까?</span>

- malloc -> new/delete
	- malloc은 c언어에서 동적 메모리 할당을 하기 위한 선언문으로 사용이 되었다. 한창 c언어의 개발이 주를 이루던 시기에는 ms-dos와 같은 tiny os가 운영체제로 있어서 메모리 관리에 큰 주의가 필요했다.(당시 RAM의 크기도 매우 작았다.) malloc은 메모리 할당이 불가능하거나, 모종의 이유로 실패할 경우 NULL을 반환했는데, window95로 넘어오면서 intel의 RING이라는 시스템이 도입되어 컴퓨터 내부에서 LEVEL이 나누어지게 되었는데, 이때 위 [[3.I/O]]에서 배운 User/Kernel층이 나뉘어지게 된다. OS가 층이 나뉘고, 메모리가 진화하면서 자연스럽게 OS가 컴퓨터자원을 직접 통제할 수 있게 되자, malloc에 실패하는 상황이 줄어들고, 예외처리가 OS내부에 도입되며 malloc이 연산자가 되었다. 그것이 new 연산자로 바뀌게 된 것이다.
	- 그럼 무엇이 malloc과 달라졌을까 라고 생각해보았을때, new의 역할은 다음과 같다.
		1. 동적 메모리 할당
		2. class 생성자 함수 호출
		1번은 malloc과 동일하지만, 2번이 다르다는 것을 확인할 수 있다.

- 포인터/참조자
	- 참조자은 const + 포인터 라고 생각하면 편하다
	- 변수에 '별명'을 추가해주는 방식인데, 포인터는 변수의 주소를 복사하여, 직접적으로 제어가 가능하다. 하지만 가장 큰 단점이 포인터는 '변수'라는 것이다.
```c++
int n = 10;
int m = 5;

int *nptr = &n;
*nptr = &m;
```
위와 같은 식으로 한 개의 포인터 변수가 두 개 이상의 변수를 순차적으로 가르키는 코드가 작성될 수도 있다. 추후에 포인터가 어떤 변수를 가르키고 있는지 혼동이 올 수도 있다. 따라서 참조자를 통해 이의 단점을 보완하였고, 참조자는 재정의가 불가능하다. 이점을 제외하고는 포인터처럼 주소를 가르킨다는 것은 동일하다.



- 후행반환형
	- 함수 혹은 메서드의 반환형을 명확시 하거나, 반환형이 여러방향으로 존재할 경우 오버로딩을 피하기 위해 사용된다. 코드를 예제로 이해해보자.

```c++
int add(int a, int b){return a+b;}
double add(double a, int b){return a+b;}
double add(int a, double b){return a+b;}
double add(double a, double b){return a+b;}
```

이런식으로 코드를 짤 때, 반환형이 여러 개이거나, 매개변수의 자료형이 여러가지 존재할 경우, 오버로딩을 피할 수 없다. 하지만 후행반환형을 사용하게 되면

```c++
auto add(auto a, auto b) -> decltype(a+b){return a+b;}
```

이런식으로 사용이 된다. 보통 위와 같이 매개변수의 자료형이 다양할 경우, auto를 사용하는 것보단

```c++
template <typename T1, typename T2>
auto add(T1 a, T2 b) -> decltype(a+b){return a+b;}
```

로 template 함수를 통해 구현할 수 있다.

- 멤버 이니셜라이저 리스트 : const, static과 같이 생성과 동시에 초기화 해야하는 변수들을 다룰때 유용하다. 생성자를 선언하면서 멤버변수의 초기화가 이루어지는데, 이때 생성자 본문에서 초기화가 이루어지는 것이 아닌 멤버 변수 선언과 동시에 초기화가 이루어진다.

```c++
class example{
private:
	const int value;
public: 
	example(int n) : value(n){}
};
```

위와 같이 멤버 이니셜라이저를 사용하게 되면

```c++
const int value = n;
```

와 동일한 문장으로 처리된다. 이는 곧 const와 같이 생성과 초기화가 동시에 이루어져야 할 때 유용하기도 하지만,

```c++
//normal
int n;
n = 10;

---------
//member initializer
int n = 10;
```

불필요한 재할당이 필요가 없어져서 성능면으로도 우수하다.

가장 큰 단점으로 this연산자를 사용할 수 없다는 것인데,

```c++
class example{
private:
	const int value;
public:
	example(int value) this->value(value){} // error!
}
```

와 같은 코드를 구현할 수 없다는 것이다.

이를 해결하기 위해선 c++20부터 지원하는 lambda capture style을 사용하면 되는데, 이는 람다캡쳐스타일에서 자세히 알아보겠다.

## 3. Namespace, function

- default parameter : 함수 매개변수를 선언과 동시에 초기화하여 실수인자를 넘겨주지 않아도 자동으로 변수값이 초기화된다. 우측부터 순차적으로 이루어져야 하며, 우측 매개변수의 초기화 없이 좌측 매개변수만 초기화를 하면 컴파일 오류가 발생한다.
```c++
int sum(int, int = 10); // o
int sum(int = 10, int) // x
-> sum(10)을 선언할 경우 좌측 int변수에 값이 대입되어 우측 매개변수 값이 초기화 되지 않아 컴파일 오류
```
*Google Coding Style Guide에서 사용을 지양함 -> 코드의 원본을 식별하기 어렵기 때문*



- labda capture style
- static
- 
- 
