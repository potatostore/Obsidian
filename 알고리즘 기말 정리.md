# 1. 조합

$$
nCr = \frac{n!}{r!(n-r)!}
$$

# 2. 플로이드 알고리즘(최단거리)

1. 총 node의 수가 n개일 때 -> nxn배열을 통해 노드 간의 관계를 정리
2. 만약 1->2로 가는 화살표의 가중치가 7일 경우 $v[1][2]$ = 7과 같이 정리.
3. 이때 2->1로 가는 화살표가 없는 경우가 발생할 수 도 있음 -> 이럴 경우 무한으로 처리
4. 코드의 흐름을 따라가다 보면 최단 거리가 배열 내에 저장


# 3. 허프만 코드 + 압축률

- **Z(2), X(5), B(7), S(9), M(10), A(12), I(18)**
### 1. 허프만 트리 구성 과정

- 새로운 노드 `(ZX)` 생성, 빈도수: 2 + 5 = **7**
    
- 남은 노드들: **B(7), (ZX)(7)**, S(9), M(10), A(12), I(18)
    

**단계 2: 가장 작은 B(7)와 (ZX)(7)를 묶습니다.**

- 새로운 노드 `(BZX)` 생성, 빈도수: 7 + 7 = **14** (두 빈도수가 같은 노드끼리는 왼쪽 오른쪽 상관 없음)
    
- 남은 노드들: S(9), M(10), A(12), **(BZX)(14)**, I(18)
    

**단계 3: 그다음 작은 S(9)와 M(10)을 묶습니다.**

- 새로운 노드 `(SM)` 생성, 빈도수: 9 + 10 = **19**
    
- 남은 노드들: A(12), (BZX)(14), I(18), **(SM)(19)**
    

**단계 4: A(12)와 (BZX)(14)를 묶습니다.**

- 새로운 노드 `(ABZX)` 생성, 빈도수: 12 + 14 = **26**
    
- 남은 노드들: I(18), (SM)(19), **(ABZX)(26)**
    

**단계 5: I(18)와 (SM)(19)를 묶습니다.**

- 새로운 노드 `(ISM)` 생성, 빈도수: 18 + 19 = **37**
    
- 남은 노드들: (ABZX)(26), **(ISM)(37)**
    

**단계 6: 마지막 남은 두 노드 (ABZX)(26)와 (ISM)(37)을 묶습니다.**

- 최종 루트 노드 생성, 빈도수: 26 + 37 = **63**

### 2. 코드 할당 
|**Letter**|**Frequency**|**Code (예시)**|**비트 길이**|
|---|---|---|---|
|**I**|18|**10**|2|
|**S**|9|**110**|3|
|**M**|10|**111**|3|
|**A**|12|**00**|2|
|**B**|7|**010**|3|
|**X**|5|**0111**|4|
|**Z**|2|**0110**|4|

### 3. 압축률

1. 문자의 종류 = 7종류 -> 2^3으로 표현가능하므로 최소 3bit필요
2. 위 코드할당표의 Frequency를 전부 더함 -> 63개
3. 63 * 3 = 189.
4. 위 코드할당표의 Frequency * 비트 길이를 전부 더함 -> 166
5. 166/189 * 100 = 약 87.8% (압축률)

# 4. (a+b)^n 이항정리

