Clean Architecture이란 Clean Code로 만들어진 벽돌은 무지성으로 쌓아올리는 것이 아닌 가장 효율적이고 정갈하게 쌓는 것이다.

특히 책에서 밝히는 목표는 유지보수가 가능한 코드를 작성하므로서 추후에 발생하는 비용을 절감하는데 의의를 둔다.

이 책은 프로그래밍의 기초를 천천히 알려주며, 추후에 어떤 점을 개선하거나, 어떻게 코드를 쌓아 올려야 유지보수가 가능한 코드가 가능한지 알려주는 것이며, 코드가 클린하다는 점을 전제로 깔고 가기에 [[Clean Code]]를 병행하며 읽으면 시너지가 발생한다는 점을 쉽게 이해할 수 있다.

개발자는 코드 작성만이 중요한 것이 아니다. 코드를 어떻게 쌓아올리는지에 따라 유지보수의 방향성이 달라지고, 이는 곧 소프트웨어 전체적인 부분에 영향을 줄 것이다.

## 1. 설계와 아키텍처
---

아키텍처를 한글로 번역하게 되면 설계가 되지 않을까? 라는 의문과 함께 설계와 아키텍처를 같은 동의어로 이해하고 넘어가는 경우가 많다.

- 아키텍처 : 저수준의 세부사항과는 분리되는 고수준의 무언가를 가르킴
- 설계 : 저수준의 구조 또는 결정사항 등을 의미함

여기까지가 책에 저술된 내용인데, 상당히 모호한 표현이라고 생각이 된다.

프로젝트의 저수준과 고수준의 경계선이 매우 모호하기 때문이다.

흔히 *고수준*이라는 단어를 사용하게 되면 전체적인 면이라고 생각할 수 있다. 

이를 바탕으로 좀 더 구체화하면 프로젝트를 구상할 때, 어떤 기능들을 구현할 것인가?에 대한 것은 고수준이며, 이 기능들을 어떻게 구현할까? 라는 것은 저수준이라고 생각할 수 있다.

그렇기에 아키텍처를 시스템 전체적인 구조와 기능, 그리고 그 기능들의 관계를 가르킨다고 볼 수있고,
설계는 그 기능들을 어떻게 구현할 것인지에 대해 구상화하는 것을 말한다고 볼 수 있다.

그렇다면 위 내용들을 바탕으로 설계에 대한 방식과 규칙을 유도하는 규칙이 [[Clean Code]]이고, 이 설계를 바탕으로 유기적인 소프트웨어를 제작하는 방법을 알려주는 책이 [[Clean Architecture]]라고 이해할 수 있다.

저자가 밝히기를 이 책을 쓴 이유는 시스템의 유지보수를 하는데 필요한 인력을 최소화한다라고 볼 수 있다.

## 2. 두 가지 가치에 대한 이야기
---

모든 소프트웨어 시스템은 개발자에 의해 개발이 되고, 이에 대한 가이드를 이해관계자(관리자 등)에게 넘김으로서 프로그램의 유지보수를 맡긴다.

이때 개발자는 유지관계자에게 두 가지 가치를 제공해야하는데, 이를 *행위*와 *구조*이다.

- 행위(behavior) : 개발된 프로그램이 어떤 가치를 갖고, 어떤 기능을 실현시킬 수 있는지
- 구조(architecture) : 개발된 프로그램이 어떤 구조를 갖고 있는지

위 두 가지 가치를 지니고 있어야 온전한 소프트웨어가 발생한다.

본래 소프트웨어는 부드러운이라는 형용사가 붙은 만큼 기계의 행위가 쉽게 변할 수 있도록 개발해야 한다.

그렇다면 소프트웨어는 두 가치 중 어떤 것이 더 중요할까?

볼 것도 없이 당연히 구조이다.

아이젠하워 매트릭스가 말하길 세상에는 4가지 종류의 문제가 있다고 했다.

1. 긴급하고, 중요한 문제
2. 긴급하지는 않지만, 중요한 문제
3. 긴급하지만, 중요하지는 않은 문제
4. 둘 다 아닌 문제

위 순서대로 중요도를 갖는다고 주장했는데, 긴급한 문제는 중요도를 뺴먹을 수 있지만, 중요한 문제는 긴급하지 않더라도 나중에 프로그램의 성능면에서 큰 부분을 차지할 수도 있다고 생각하기 때문이다.

## 3. 패러다임 개요
---

패러다임이란 프로그래밍을 하는 방법이다.

다양한 방법이 존재하겠지만, 우리에게 익숙한 것들은 OOP, 절차지향 프로그래밍, 함수형 프로그래밍 등이 존재한다.

이 책에서는 세 가지의 패러다임을 중요시 여기는데, 구조적 프로그래밍, 객체 지향 프로그래밍, 함수형 프로그래밍이다.

#### 구조적 프로그래밍
---
- 데이크스트라가 goto와 같은 점프문을 코드에 해롭다는 사실을 인지하고, 이를 if~else/while등의 점프로 바꾸었다.
- 제어흐름의 직접적인 제어에 대한 규칙을 부과한다.

#### 객체 지향 프로그래밍
---
- 구조적 프로그래밍보다 2년 앞선 시기에 등장한 개념으로, 함수 호출 스택 프레임을 힙 영역에 옮기게 되면 함수가 반환되어도 함수에서 사용된 지역변수가 남아있다는 것을 발견한 후 착안된 개념이다.
- 제어흐름의 간접적인 제어에 대한 규칙을 부과한다.

#### 함수형 프로그래밍
---
- 불변성을 근간으로 둔 람다 계산법을 통해 변수를 까다로운 조건에서 할당하고, 초기화를 하더라도 변화하는데 큰 제약을 부여하는 방식이다. 비교적 최근에 조명받았지만, 사실 가장 먼저 착안된 개념이다.
- 할당문에 규칙을 부과한다

책의 내용은 상당히 이해하기 어렵게 작성이 되었는데, 각 패러다임이 무엇이고, 어떤 규칙을 부과하는지에 대한 서술은 이해가 되지만, 각 패러다임이 세상에 나오게 된 계기가 무엇인지 모르고, 그러기에 기초한 개념에 대한 이해가 상당히 어려웠다.

핸드폰을 꺼내 검색을 시작하려던 시점에 다음 목차가 *구조적 프로그래밍*인 것을 확인하고 굉장히 잘 짜여있는 책임을 다시 한번 확인했다.

## 4. 구조적 프로그래밍
---

데이크스트라는 1950년대, 아직 프로그래밍이라는 직업이 탄생하지 않고, 하나의 공학으로 인정받지 않던 시절에 프로그램을 작성하면서 많은 프로그래머들이 프로그래밍을 잘하지 못한다는 사실을 인지하고, 프로그램이 아주 작은 세부사항이라도 놓지게 되면 오류를 불러 일으킨다는 점을 인지했다.

수학이라는 증명을 통해 참임을 밝히는 학문을 통해 데이크스트라는 이를 해결하려고 노력했다.

그가 사용하는 방식은 유클리드의 계층구조이다.

*유클리드 계층구조 : 공리라는 증명이 없어도 항상 참으로 받아들여지는 명제를 뜻한다. 이러한 공리가 만들어지기 위해 정리라는 증명을 통해  참이라는 것이 밝혀진 명제들이 필요했고, 이러한 구조를 만드는 것을 뜻한다.*

즉 입증된 구조를 통해 코드를 작성하고, 이를 통해 코드가 입증되었다는 것을 스스로 증명하게 만들고 싶었던 것이다.

그 과정에서 간단한 알고리즘부터 증명하는 과정을 거쳐야 가능한데, 이는 상당히 힘든 과정이다.

연구 과정에서 goto문장이 모듈을 더 작은 단위로 재귀적으로 분해하는 과정에 방해가 되는 경우가 있다는 사실을 발견하였다.

만약 모듈을 분해하지 못한다면 합리적으로 증명할 때 필수적으로 사용되는 기법인 *분할 정복 접근법*을 사용하지 못한다.

그는 goto문장을 사용하더라도 모듈을 분해할 때 문제가 되지 않는 경우들을 분석하였고, 이는 if/else/do/while과 같이 분기와 반복이라는 단순한 제어 구조에 해당한다는 사실을 발견하였다. 즉 goto문을 굳이 사용하지 않더라도 goto문을 좋은 방면으로 사용한 것과 동일한 효과를 발생할 수 있다는 점이다. 그렇기에 

## 5. 객체 지향 프로그래밍


## 6. 함수형 프로그래밍


## 7.  SRP : 단일 책임 원칙


## 8. OCP : 개방-폐쇄 원칙


## 9. LSP : 리스코프 치환 원칙


## 10. ISP : 인터페이스 분리 원칙


## 11. DIP : 의존성 역전 원칙


## 12. 컴포넌트


## 13. 컴포넌트 응집도


## 14. 컴포넌트 결합


## 15. 아키텍처


## 16. 독립성


## 17. 경계 : 선 긋기


## 18. 경계 해부학


## 19. 정책과 수준


## 20. 업무 규칙


## 21. 소리치는 아키텍처


## 22. 클린 아키텍처


## 23. 프레젠터와 험블 객체


## 24. 부분적 경계


## 25. 계층과 경계


## 26. 메인 컴포넌트


## 27.  크고 작은 모든 서비스들


## 28. 테스트 경계


## 29. 클린 임베디드 아키텍처


## 30. 데이터베이스는 세부사항이다


## 31. 웹은 세부사항이다


## 32. 프레임워크는 세부사항이다


## 33. 사례 연구 : 비디오 판매


## 34. 빠져 있는 잠

