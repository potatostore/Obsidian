- 각 숫자를 적절한 위치에 삽입하여 정렬한다.

처음에 위 정의를 보고 곧바로 생각이 나지 않았다.
그 이유는 적절한 위치의 기준이 무엇인지 전혀 감이 안잡히기 때문이다.

먼저 인간의 경우 배열을 보면 그 배열의 오름차순을 특별한 과정 없이 정렬이 가능한데, 컴퓨터의 경우 구체적인 방안을 제시해야 수행할 수 있다고 본다.
구체적인 방안을 제시해야 하는 우리는 적절한 위치의 기준에 대해 생각을 해보아야 한다.

예제를 보며 정의해보자.

```c++ title='오름차순' hl=14
#include <iostream>  
#include <vector>  
  
using namespace std;  
  
vector <int> v = {1,10,5,8,7,6,4,3,2,9};  
  
int main() {  
    for(int i=0;i<v.size();++i) {  
        for(int j=i-1;j>=0;j--) {  
            if(v[j] > v[j+1]) {  
                swap(v[j],v[j+1]);  
            }  
            else break;
        }  
    }  
  
    for(auto i : v) cout << i << " ";  
  
    return 0;  
}
```

적절한 위치의 기준이 필요가 없었다. 테스트 배열을 기준으로 좌측에 정렬된 부분을 차츰 늘려가는 것이 삽입정렬의 포인트라고 생각한다. 키 포인트는 14번째 줄이라고 생각하는데, 저 한줄로 정렬되어 있는 좌측항에 새로운 원소의 위치를 넣는 것이 더 빠르게 실행된다고 생각한다.

특히 삽입정렬의 경우 

*2 3 4 5 6 7 8 9 10 1*과 같이 좌측 항이 전부 정렬이 되어 있고, 이에 새로운 원소만 집어 넣어 정렬을 이루고 싶을 때 가장 유용하게 사용될 것 같다.

특징
1. 시간복잡도 O(n^2)
2. 테스트 케이스를 봤을 때 한 쪽이 정렬이 되어 있으면 꽤 빠른 속도를 보여준다.

[[1. Selection Sort]], [[2. Bubble Sort]]과 시간복잡도는 동일하지만, 특수 케이스에서 꽤나 빠른 속도를 보여준다는 점에서 진짜 가끔 쓰일 것 같다.