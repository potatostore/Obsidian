- 각 숫자를 적절한 위치에 삽입하여 정렬한다.

처음에 위 정의를 보고 곧바로 생각이 나지 않았다.
그 이유는 적절한 위치의 기준이 무엇인지 전혀 감이 안잡히기 때문이다.

먼저 인간의 경우 배열을 보면 그 배열의 오름차순을 특별한 과정 없이 정렬이 가능한데, 컴퓨터의 경우 구체적인 방안을 제시해야 수행할 수 있다고 본다.
구체적인 방안을 제시해야 하는 우리는 적절한 위치의 기준에 대해 생각을 해보아야 한다.

예제를 보며 정의해보자.

```c++ title='오름차순'
#include <iostream>  
#include <vector>  
  
using namespace std;  
  
vector <int> v = {1,10,5,8,7,6,4,3,2,9};  
  
void insertion(int i, int n);  
  
int main() {  
    vector <int> output;  
  
    for(auto i : v) {  
        bool isInsertion = false;  
        if(output.empty() == true) {  
            output.push_back(i);  
            continue;  
        }  
        else {  
            for(int j=0;j<output.size();++j) {  
                if(i < output[j]) {  
                    isInsertion = true;  
                    output.insert(output.begin()+j,i);  
                    break;  
                }  
            }  
        }  
  
        if(isInsertion == false) {  
            output.push_back(i);  
        }  
    }  
  
    for(auto i : output) cout << i << " ";  
  
    return 0;  
}
```

우선 예제를 풀면서 느낀 점은 생각보다 적절한 기준을 찾는 것이 중요하지 않다는 점이다.
물론 문제가 요구하는 바를 정확하게 파악하는 것은 알고리즘의 기초이다. 하지만 삽입정렬에서 알려준 적절한 위치는 만약 문제에서 오름차순을 요구하는 것이면 오름차순에 맞는 적절한 기준을 세우고 그에 따라 배치하면 되기에 생각보다 크게 신경이 쓰지 않았다.

특징
1. 시간복잡도가 O(n^2)이다. : 현재 나온 3개의 정렬이 모두 동일하지만 알고리즘 상에서 이정도의 시간복잡도는 항상 실전에서 특별한 이점이 존재하지 않는 이상 선택하기 어렵다고 생각하면 된다.
2. 컨테이너(배열)이 한 개 더 필요하다. : 큰 특징은 아니지만 나중에 메모리를 잡아먹을 수 있다고 생각이 드는 부분이다. 그 이유는 테스트의 수가 많아질 수록 두 개의 배열을 사용하기에 그에 따른 메모리를 추가로 소모할 수 있다고 판단했기 때문이다.