백트래킹(Backtracking) 알고리즘은 기본적으로 탐색 알고리즘의 일종으로, 재귀를 통해 해를 찾는 알고리즘 유형이라고 볼 수 있다. 

<span style="color:rgb(255, 247, 0)">후보 해들을 구성한 후, 이 해들이 가능한지 판단을 한 후, 가능성이 없으면 이전 단계로 돌아가 다른 경로를 찾아보는 방법이다. </span> 

이를 통해 모든 가능한 경우의 수를 탐색하여 원하는 해를 찾는 과정을 효율적으로 찾을 수 있다.
-> 모든 가능한 경우의 수를 탐색한다는 부분에서 시간복잡도가 상당할 것을 예측할 수 있다.

백트래킹은 기본적으로 해를 찾는 과정을 세 단계로 나눌 수 있다.

# 기본원리
1. 상태 공간 탐색(State Space Search) : 가능한 모든 해를 표현할 수 있는 상태 공간을 탐색
2. 후보 해 선택(Selection of Candidate Solution) : 재귀적으로 가능한 해 구성, 확장
3. 백트래킹(Backtracking) : 더 이상 유효하지 않는 해라고 판단할 경우, 해당 경로를 포기하고 다른 경로 탐색

이는 가능한 모든 해를 한 번씩 탐색한다는 점에서 [[Brute-Force Search]]와 매우 유사하지만, 유망하지 않는 경로는 중간에 빠르게 버린다는 점에서 완전 탐색보다는 조금 더 최적화가 되어 있다고 볼 수 있다.

# 주요개념

- DFS를 기반으로 작동한다.
- 조건부 포기(Pruning), 즉 일정 조건을 만족하지 않는 해는 더 이상 탐색하지 않고, 되돌아간다.
- 백트래킹을 통해 후보 해집합을 유지하고, 이를 재귀 호출을 통해 확장 및 축소한다.

# 사용유형

1. **조합(combination) 문제**: 주어진 집합에서 특정 개수의 요소를 선택하는 경우.
2. **순열(permutation) 문제**: 주어진 집합의 요소를 서로 다른 순서로 배치하는 경우.
3. **그래프 탐색(graph traversal)**: 그래프의 특정 조건을 만족하는 경로를 찾는 문제.
4. **제약 충족 문제(Constraint Satisfaction Problems)**: 특정 조건을 만족하는 해를 찾는 경우.
5. **최적화 문제(Optimization Problems)**: 주어진 문제에서 최적의 해를 찾는 경우.

# 시간복잡도

백트래킹의 정의를 이해하면 자연스럽게 시간복잡도가 매우 높을 것을 예측할 수 있을 것이다.
백트래킹은 문제의 크기와 해집합의 수가 많아질수록 시간복잡도가 기하급수적으로 늘어나는데, 실제로 O표기법으로 나타냈을때, O(b ^ d)라고 볼수 있다.
- b : 각 노드에서 확장할 수 있는 자식 노드의 수(브랜치 팩터)
- d : 해를 찾기 위해 내려가야 하는 깊이(문제의 크기)

n제곱의 시간복잡도를 갖는 알고리즘은 매우 무겁고, 거의 사용이 불가능할 정도의 효율을 보여주기에 백트래킹은 제약 조건을 추가하여 탐색 범위를 줄여나가는 것을 큰 목표로 한다(이를 가지치기라고 한다, Pruning)

# 장단점

- 장점 : 
	- 이해, 구현이 쉽다.
	- 가능한 모든 해를 탐색가능하다.
	- 유망하지 않는 경로를 빠르게 제거 가능하다.
- 단점 : 
	- 시간복잡도가 매우 높아 성능문제로 이어진다.
	- 재귀호출이 많아질 경우 스택오버플로로 이어질 수 있다.
