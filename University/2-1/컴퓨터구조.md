## Computer
- 산술/논리 연산을 자동으로 실행하는 장치
- 물리적인 실체 : H/W
- H/w의 션산을 지정 및 명령해주는 집합체 : S/W
- 전류의 크기를 조절하는 장치 : transistor
- cpu/Ram이 한번에 처리하는 데이터의 단위 : Word

## System
- 구성요소들이 목표달성을 위해 작동하는 집합체

#### CPU/RAM의 정보 교환 통로
- System bus : 정보 교환 통로
	- 주소 버스 : 데이터의 주소가 이동하는 통로 ->단방향
	- 데이터 버스 : 데이터가 이동하는 통로 -> 양방향
	- 제어 버스 : 동작 제어 신호가 이동하는 통로 -> 단방향

#### Buffer
- 데이터가 일시적으로 머물고 가는 저장공간
- data buffer : cpu와 I/O사이에 일시적으로 데이터가 머무는 장소
- disk buffer : HD/SSd와 같은 디스크에서 데이터를 불러올 떄 일시적으로 머무는 장소

#### 역할/기능
- 프로그램 실행 : cpu가 주 기억장치로부터 코드를 읽어 실행
- 데이터 저장 : 실행 결과로 얻은 데이터를 주 기억장치에 저장
- 데이터 이동 : HD/SSd의 Program/Data를 주 기억장치로 이동
- 데이터 입력/출력 : I/O장치들로부터의 데이터를 읽거나 출력
- 제어 : 프로그램이 순서대로 실행되도록 유도 + 순서변경 조정에 필요한 각종 제어 신호

## CPU
- 중앙 처리 장치

#### 구성요소
- 산술논리연산장치 : ALU : 산술/논리 연산 수행 회로들이 모인 H/W module
- 레지스터 세트 : Resistor Set : CPU내부에 위치한 기억장치
- 제어 유닛 : Control unit : 코드 해석 및 실행을 위한 신호들을 순차적으로 발생

#### 명령어
- CPU가 동작하도록 지시하는 전기신호의 집합

#### 사이클 
- 명령어 사이클 : 1개의 명령어를 수행하기 위해 필요한 과정
	- 명령어 인출(인출 사이클) : 기억장치에 저장된 명령어 가져오기 
	- 명령어 실행(실행 사이클) : 가져온 명령어 실행 

- 실행에 필요한 resistor
	- Program Counter(PC) :다음에 인출될 명령어 주소를 갖고 있다.
	- 누신기(AC) : 연산에 필요한 데이터를 일시적으로 저장, Word의 크기와 동일
	- 명령어 레지스터(IR) : 최근에 인출된 명령어 저장
	- 명령어 주소 레지스터(MAR) : PC에서 주소버스를 통해 메모리에 접근 전에 주소를 일시적으로 저장
	- 기억장치 버퍼 레지스터(MBR) : 읽힌 데이터를 일시적으로 저장

- 명령어 인출 사이클 
	- t0 : MAR <- PC                                 : PC의 명령어를 MAR로 내부버스를 통해 이동
	- t1 : MBR <- M[MAR] + PC = PC+1  : 주소 버스를 타고 기억장치속 MAR주소에 접근해 데이터를 데이터 버스를 통해 MBR로 이동 + PC counter를 올려 다음 명령어 준비
	- t2 : IR <- MBR                                  : 가져온 데이터는 명령어 이므로 IR에 저장

- 실행 사이클
	- 데이터 이동 : cpu/기억장치 or CPU/I/O 장치간에 데이터 이동(LOAD)
		- t0 : MAR <- IR(addr)
		- t1 : MBR <- M[MAR]
		- t2 : AC <- MBR
	- 데이터 처리 : 산술 논리 연산 수행(ADD, SUB ...)
		- t0 : MAR <- IR(addr)
		- t1 : MBR <- M[MAR]
		- t2 : AC <- AC + MBR
	- 데이터 저장 : 연산 결과 데이터 / 입력장치로부터 불러온 데이터를 M에 저장(STA)
		- t0 : MAR <- IR(addr)
		- t1 : MBR <- AC            : 연산 결과 저장시에만
		- t2 : M[MAR] <- MBR
	- 제어 : 실행 순서 결정(JUMP : 제어문의 결과값에 따라 실행되는 명령어가 달라짐)
		- t0 : PC <- IR(addr)

- 인터럽트 사이클 : 실행사이클 중간에 다른 명령어가 먼저 수행하도록 제공하는 매커니즘(다만 현재 실행중인 명령어가 있다면 먼저 끝내고 다음 명령어가 실행되기 전에 인터럽트 사이클을 실행함)
	- ISR : 인터럽트 서비스 레지스터로 인터럽트가 발생했을 때 실행되는 명령어
	- t0 : MBR <- PC
	- t1 : MAR <- SP, PC <- ISR
	- t2 : M[MAR] <- MBR, SP<-SP-1

- 간접 사이클 : 실행 사이클에서 사용될 데이터의 실제 주소를 기억장치로부터 읽어오는 과정
	- t0 : MAR <- IR(addr)
	- t1 : MBR <- M[MAR]
	- t2 : IR(addr) <- MBR
#### OP code / Operand
- OP code : 연산 코드 (명령어)
- Operand : 명령어가 사용할 데이터가 저장된 공간
- LOAD 255 -> OP code : LOAD, Operand : 255
- 1255 -> OP code : 1, Operand : 255

- 74p 그림 [2-6]

## 파이프라이닝 
- 실행 사이클을 여러 단계로 나누고 이를 분할 실행하여 CPU의 성능을 높여줌

*파이프 라인이 이론만큼 속도가 안나는 이유 : 분기문을 만났을 때 파이프라인을 통해 생성된 단계가 깨지고 다른 명령어 실행 -> 분기 예측을 통해 어느정도 해결*

#### Multi-Core / Multi-Thread
- multi-Core : 여러 코어를 통해 여러 프로세스를 물리적으로 동시에 처리하도록 만듬
- multi-thread : 한 프로세스를 여러 단계로 쪼개 처리. 메모리 공유를 통해 동시에 처리하면서 동기화 문제 발생

## 주소 지정 방식

#### 기호 / 표기
- EA : 유효 주소, 데이터가 저장된 기억장치 실제 주소
- A : Operand 값이 데이터가 아닌 주소일 경우
- R : 명령어 내의 레지스터 번호
- (A) : A번지 내용
- (R) : 레지스터 R의 내용

#### 직접 주소 지정 방식 
- EA = A
- Operand에 메모리 주소가 담겨있음

#### 간접 주소 지정 방식
- EA = (A)
- 2^operand 메모리 값 만큼 주소 읽기 가능
- Operand에 주소가 담겨있고, 이를 한 번 더 타고 가면 메모리 주소를 얻을 수 있다.
- 메모리 주소 접근 범위가 증가하지만 메모리 접근 사이클이 증가한다.

#### 묵시적 주소 지정 방식
- SP : Stack Point, 스택 메모리의 최상위 주소를 저장하고 있는 레지스터, 현재 진행상황 저장용, 저장할 R 위치를 묵시적으로 저장

#### 레지스터 주소 지정 방식
- EA = R

#### 레지스터 간접 주소지정 방식
- EA = (R)

#### *변위 주소 지정 방식*
- EA = A+(R)
- Operand에 index, 시작주소, 원소 크기 포함
- ASLR을 통해 바뀐 메모리 주소를 따라가기 위해 기준점(시작주소 등)을 통해 분기문 등을 효율적으로 처리

#### 상태 주소 지정 방식
- EA = A+(PC)

#### ISA
- 명령어들의 집합
	- CISC : 명령어가 많고, 주소지정 방식이 매우 다양항
	- RISC

#### 엔디언
- 바이트를 읽는 순서
	- big endian : 큰수 먼저(순차적으로)
	- little endian : 작은수 먼저(역순으로)

## ALU
- 산술연산 : 

#### 정수 표현
- 부호화-크기 표현 : +-0 존재(표현 범위가 줄어듬) / 음수표현에 대해 별도의 회로 설계
- 1의 보수 : 두 번째 문제 해결, 첫 번째 문제 해결 못함
-가
	- E = 지수부분, 표현범위
	- M = 가수부분, 표현정확도
- O/F : 표현 범위보다 크거나 작아 표현 불가능한 범위
- U/F : 표현 범위 사이에 표현 불가능한 범위
- 222P E/M에 따른 N표현 확인

#### 논리 연산(캐스팅)
- AND gate
- OR gate
- XOR gate
- NOT gate
- 선택적-set 연산 : OR 연산을 통해 B레지스터에서 1로 표기된 비트들과 같은 위치의 비트들을 1로 설정
- 선택적-보수 연산 : XOR 연산을 통해 위 과정을 반전시켜 설정
- 삽입 연산 : 살리고 싶은 bit를 1, 아닌 것을 0으로 두고 AND 연산 후 원하는 비트를 OR 연산을 통해 비트 삽입
- 비교 연산 : 분기문 같이 대소비교 등에 사용, XOR