
```r
df <- read.csv("파일명", header=TRUE) // header = TURE -> 1행을 종류로 간주

//데이터 필터링 및 선택
subset(df, 조건) // 조건에 만족하는 셋을 뽑아냄
df[조건, c("Name", "Score"...)] // 조건에 맞는 행과 열을 직접 지정 추출(뒤에 c를 안붙이면 행 전체, df[조건, ])

subset(df, df$Age > 20 & df$Score >= 80)
df[df$Age > 20 & df$Score >= 80, c("Name", "Score")] // c()를 통해 여러 열을 동시에 선택 가능

//정렬하기
sort(df$, decreasing=False) // 오름차순 정렬
df[order(df$, decreasing=False)] // 특정 열 기준으로 정렬된 데이터프레임 반환
which.max(df$Petal.Width) // Petal.Width가 가장 큰 인덱스 반환
p5 = df[which.max(df$Petal.Width)]

//최대,최소
max()
min()

✅ 문제 1: `iris` 데이터셋에서 **`Petal.Length`가 5 이상인 데이터**만 추출하세요.

- 힌트: `subset()` 또는 `filter()` 사용
    

✅ 문제 2: 위에서 추출한 데이터 중 **품종이 "virginica"인 행만** 다시 추출하세요.

✅ 문제 3: 조건을 만족한 데이터에서 **`Species`와 `Petal.Length` 열만 출력**하세요.

✅ 문제 4: `Petal.Length`를 기준으로 **내림차순 정렬된 결과**를 출력하세요.

✅ 문제 5: **`Petal.Width`가 가장 큰 꽃의 품종과 길이**를 출력하세요
---------------------------------------------
df<-iris

p1 = subset(df, df$Petal.Length >= 5.0)  

p2 = subset(p1, p1$Species == "virginica")  

p3 = p2[c("Species", "Petal.Length")]  

p4 = sort(df$Petal.Length)  

p5 = df[which.max(df$Petal.Width), ]
---------------------------------------------

df <- read.csv("students.csv", header=TRUE)

p2 = subset(order(df$Age >= 20 & df$Score >= 80))

p3 = subset(p2$Name, p2$Score)

p4 = sort(df$Score, decreasing = TURE)

p5 = df$Name[p4[0] == df$Score]

---------------------------------------------
✅ 문제 2: `Species`별로 `Sepal.Length`의 평균값을 구하세요.

✅ 문제 4: `Species`별로 `Sepal.Length`의 평균과 `Sepal.Width`의 평균을 구한 후, 결과를 `Sepal.Length` 기준으로 내림차순 정렬하세요.

p2 = aggregate(Sepal.Length ~ Species, data = iris, FUN = mean)

p4 = aggregate(cbind(Sepal.Length, Sepal.Width) ~ Species, data = iris, FUN = mean)
p4[order(p4$Sepal.Length)]

----------------------부서별 평균 구하기
library(dplyr)

df %>%
  group_by(department) %>%
  summarise(avg_salary = mean(salary))
  
write.csv(result, "avg_salary_over_3yrs.csv", row.names = FALSE)

-----------------------
# 데이터 불러오기
df <- read.csv("data/weather.csv", header = TRUE)

# 날짜를 Date 타입으로 변환
df$date <- as.Date(df$date)

# month 컬럼 추가
df$month <- as.integer(format(df$date, "%m"))

# 필요한 컬럼만 뽑아서 df_refined 생성
df_refined <- df[, c("month", "date", "temperature")]

# 1. 평균기온이 30도 이상인 날의 비율
output1 <- sum(df_refined$temperature >= 30) / nrow(df_refined)

# 2. 1분기(1~3월)의 평균 기온
output2 <- mean(df_refined[df_refined$month %in% 1:3, "temperature"])

# 3. 연평균보다 높은 날 중 2~3분기에 해당하는 날의 개수
year_avg <- mean(df_refined$temperature)

days_above_avg <- df_refined[df_refined$temperature > year_avg & df_refined$month %in% 4:9, ]
output3 <- nrow(days_above_avg)

# 결과 파일로 저장
write(output1, "output/out1.txt")
write(output2, "output/out2.txt")
write(output3, "output/out3.txt")

# 1. 날짜를 Date 형식으로 변환
df$date <- as.Date(df$date)

# 2. year, month, day 컬럼 추가
df$year <- as.integer(format(df$date, "%Y"))
df$month <- as.integer(format(df$date, "%m"))
df$day <- as.integer(format(df$date, "%d"))

# 3. 필요한 컬럼 정리
df_refined <- df[, c("year", "month", "day", "temperature")]
```

# ✅ 1. 데이터 구조

### 1-1. 기본 데이터 구조

- **벡터(Vector)**
복사편집

`x <- c(1, 2, 3, 4)  # 숫자 벡터`

- **리스트(List)**
    
복사편집

`lst <- list(name="홍길동", age=20)`

- **팩터(Factor)**
    
복사편집

`f <- factor(c("A", "B", "A", "C"))`

- **행렬(Matrix)**
    

복사편집

`m <- matrix(1:6, nrow=2, ncol=3)`

- **배열(Array)**
    

복사편집

`a <- array(1:8, dim=c(2,2,2))`

- **데이터프레임(Dataframe)**
    

복사편집

`df <- data.frame(id=1:3, name=c("A","B","C"))`

- **티블(Tibble)**
    

복사편집

`library(tibble) 
`tb <- as_tibble(df)  # 데이터프레임 → 티블 변환 
`tb2 <- tibble(id=1:5, name="no one", desc=paste(id, "-", name, sep=""))`

# ✅ 2. 문자열 처리

### 2-1. 문자열 생성 및 이어붙이기

- **paste()**
    
복사편집

`paste("I", "love", "R", sep="-")   paste("R v1.", 0:4)   paste(letters, collapse="")`

### 2-2. 문자열 변환

- **as.character(x)**
- **toString(x)**

### 2-3. 문자열 출력

- **print(x)**
- **noquote(x)**
- **cat(x, sep="")**
- **sprintf(format, args)**

복사편집

`sprintf("현재 %s", "문자열") sprintf("%02d번째 문자열 출력", 2) sprintf("%5.4f", pi)`

### 2-4. 문자열 길이 및 대소문자 변환

- **nchar(x)**
- **toupper(x)** / **tolower(x)**
- **chartr(old, new, x)**

### 2-5. 문자열 추출

- **substr(x, start, stop)**
- **substring(x, first, last)**
- **strsplit(x, split)**

# ✅ 3. 정규표현식 & 패턴 매칭

### 3-1. grep() - 벡터에서 패턴 검색

- **grep(pattern, x, value=FALSE, invert=FALSE)**
    
- `value=TRUE` → 일치하는 값을 반환
    

예시:

복사편집

`x <- c("RStudio", "v.0.99.484", "2015", "09-22-2015") 
`grep("[0-9]", x, value=TRUE) 
`grep("[^0-9a-zA-Z]", x, value=TRUE)`

### 3-2. grepl() - 불리언으로 반환

- **grepl(pattern, x)**

복사편집

`grepl("North", state.division) 
`sum(grepl("North", state.division))`

### 3-3. regexpr() / regmatches()

- **regexpr(pattern, x)** → 첫 매칭 위치 반환

### 3-4. sub() / gsub()

- **sub(pattern, replacement, x, ignore.case=FALSE)**
- **gsub(pattern, replacement, x)**

복사편집

`sub("Hello", "Bye", hello) 
`gsub("Hello", "Bye", hello)`

### 3-5. stringr 패키지 (더 자주 쓰임)

- **str_detect(x, pattern)**
- **str_extract(x, pattern)**
- **str_locate(x, pattern)**
- **str_replace(x, pattern, replacement)**
    

예시:

R

복사편집

`library(stringr) str_detect(state.name, "New") str_extract(x, "R[가-힣]+") str_replace(hello, "Hello", "Bye")`

---

# ✅ 4. 날짜와 시간

### 4-1. 날짜 생성 및 변환

- **as.Date("yyyy-mm-dd")**
    

R

복사편집

`d1 <- as.Date("1970-01-01")`

- **Sys.time()** → 현재 시간
    
- **as.POSIXlt() / as.POSIXct()**
    
- **strptime(string, format)**
    

R

복사편집

`strptime("2021년 12월 1일 13시 00분 11초", format="%Y년 %m월 %d일 %H시 %M분 %S초")`

### 4-2. 시간차이 계산

- 날짜 차이: `as.Date()`끼리 빼기 → difftime 객체 생성
    
- **difftime(time1, time2, units="secs/hours/weeks")**
    

R

복사편집

`difftime(t4, t5, units="hours")`

---

# ✅ 5. 사용자 정의 함수

R

복사편집

`mean_sd <- function(x, na=TRUE) {   m <- mean(x, na.rm=na)   s <- sd(x, na.rm=na)   return(c(m, s)) } mean_sd(iris$Sepal.Length)`

---

# ✅ 6. dplyr 패키지 (데이터 처리 핵심)

먼저 로드:

R

복사편집

`library(dplyr)`

### 6-1. filter() : 행 선택

R

복사편집

`filter(df, month == 1) filter(df, month == 3 & (date %% 7 == 0 | date %% 7 == 1))`

### 6-2. select() : 열 선택

R

복사편집

`select(df, 2:3) select(df, -1) select(df, c(date, supply)) select(df, date:supply)`

### 6-3. mutate() : 열 생성/변경

R

복사편집

`mutate(df, supply2 = supply / 1000)`

### 6-4. arrange() : 정렬

R

복사편집

`arrange(df, supply) arrange(df, desc(supply), desc(date))`

### 6-5. summarise() : 집계

R

복사편집

`summarise(df, n = n(), sum = sum(supply2), mean = sum / n, mean2 = mean(supply2), sd = sd(supply2))`

### 6-6. group_by() + summarise() : 그룹별 집계

R

복사편집

`group_by(df, month) %>%   summarise(days = n(), m = mean(supply), sd = sd(supply))`

### 6-7. 파이프 연산자 %>%

R

복사편집

`df %>%   filter(month %in% c(3,4,5)) %>%   mutate(supply2 = supply / 1000) %>%   select(-supply) %>%   group_by(month) %>%   summarise(n = n(), m = mean(supply2), sd = sd(supply2)) %>%   arrange(desc(month))`

---

# ✅ 7. 시각화 (base R + ggplot2)

### 7-1. base plot

- 산점도:
    

R

복사편집

`plot(x=mtcars$wt, y=mtcars$mpg)`

- 라인차트:
    

R

복사편집

`plot(x=pressure$temperature, y=pressure$pressure, type="l")`

- 히스토그램:
    

R

복사편집

`hist(mtcars$mpg)`

- 상자도표:
    

R

복사편집

`boxplot(mpg ~ cyl, data=mtcars)`

### 7-2. ggplot2

먼저 설치 및 로드:

R

복사편집

`library(ggplot2)`

- 산점도:
    

R

복사편집

`ggplot(mtcars, aes(x=wt, y=mpg)) + geom_point()`

- 색상 추가:
    

R

복사편집

`ggplot(mtcars, aes(x=wt, y=mpg, color=as.factor(cyl))) + geom_point()`

- 선형추세선:
    

R

복사편집

`ggplot(mpg, aes(x=displ, y=hwy)) + geom_point() + geom_smooth()`

- 막대그래프:
    

R

복사편집

`ggplot(mpg, aes(x=class)) + geom_bar()`

- 누적막대그래프:
    

R

복사편집

`ggplot(mpg, aes(x=class, fill=drv)) + geom_bar(position="fill")`

- 제목/축이름 추가:
    

R

복사편집

`labs(title="제목", x="x축", y="y축")`

---

# ✅ 8. 정렬 함수 요약

- **sort(x, decreasing=FALSE)**
    

R

복사편집

`sort(column, decreasing=FALSE)  # 오름차순 sort(column, decreasing=TRUE)   # 내림차순`

- **order()**  
    데이터프레임 정렬할 때 많이 사용
    

R

복사편집

`df[order(df$column), ]`