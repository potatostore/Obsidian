# 데이터의 저장
- 데이터가 물리적으로 저장되는 단위는 *Block*이지만, *Block*으로 단위화 할경우, 프로그램당 관리해야할 Block이 수없이 많아짐 -> *File*이라는 논리적 개념이 탄생

#### 파일
- 정의 : 컴퓨터의 저장장치에 데이터를 저장하는 논리적인 단위
- 목적 
	1. 프로그램과 별도로 저장하여 독립성 유지
	2. MM(Main Memory)에 효율적으로 활용
	3. 여러 프로그램 공유

---
#### 파일시스템
- 배경 : OS에서 논리적인 데이터 단위인 파일을 Memory간 효율적으로 관리하기 위해 파일시스템 탄생
- 정의 : OS가 Block 단위의 데이터들을 현실 개념 단위인 파일에 맞추어 관리하기 위한 체계
- 일반적으로 데이터를 파일로 저장하기 위해 유사한/형태가 동일한 데이터들의 집합(구조화된 데이터)로 저장

---
#### Record Type
- field : 논리적 데이터의 최소 단위
- Record : field에 맞춰 구조화된 데이터들의 모임

---
#### 데이터들의 저장 과정
1. MM로 Block단위의 데이터 이동
2. Block 사본을 갱신
3. Block Storage 내 저장위치에 Block 사본을 저장
-> 블록 읽기 시간 + 블록 갱신 시간 + 블록 사본 저장 시간 = 총 데이터 저장 시간

---
#### 데이터들을 저장하는 방법 : Blocking
- Blocking : 대량의 Record로 구성된 파일 데이터의 효율적 입출력을 위해 몇 개의 Record로 나누어 저장하는 방식
- Blocking 인수 : floor(B/R) = BF(Blocking factor)

- *블로킹 종류* 
	- 고정 길이 블로킹 : 고정 길이 레코드를 블록에 저장 -> 저장공간에 빈 공간 발생
	- 신장 가변 길이 블로킹 : 가변 길이 레코드를 인접한 블록에 빈칸없이 저장 -> 빈 공간은 없지만, 레코드를 잘라서 두 블럭에 저장하기에 해당 레코드를 MM에 올릴때, 두 블럭을 모두 올려야 되는 문제 발생
	- 비신장 가변 길이 블로킹 : 가변 길이 레코드를 신장 가변 길이 블로킹처럼 자르지 않고 저장 -> 빈 공간 발생

**고정 길이 레코드 : 레코드가 필드의 데이터 형식에 맞춰 구조가 이루어진 레코드로, 빈 공간은 padding을 통해 빈틈 없이 차있다. (field가 130byte의 구조를 형성하면, record도 130byte)
가변 길이 레코드 : 레코드가 필드의 데이터 형식에 맞춰 구조가 이루어지지 않은 레코드로, 빈 공간이 존재해 메모리의 효율이
**