# 데이터의 저장
- 데이터가 물리적으로 저장되는 단위는 *Block*이지만, *Block*으로 단위화 할경우, 프로그램당 관리해야할 Block이 수없이 많아짐 -> *File*이라는 논리적 개념이 탄생

#### 파일
- 정의 : 컴퓨터의 저장장치에 데이터를 저장하는 논리적인 단위
- 목적 
	1. 프로그램과 별도로 저장하여 독립성 유지
	2. MM(Main Memory)에 효율적으로 활용
	3. 여러 프로그램 공유

---
#### 파일시스템
- 배경 : OS에서 논리적인 데이터 단위인 파일을 Memory간 효율적으로 관리하기 위해 파일시스템 탄생
- 정의 : OS가 Block 단위의 데이터들을 현실 개념 단위인 파일에 맞추어 관리하기 위한 체계
- 일반적으로 데이터를 파일로 저장하기 위해 유사한/형태가 동일한 데이터들의 집합(구조화된 데이터)로 저장

---
#### Record Type
- field : 논리적 데이터의 최소 단위
- Record : field에 맞춰 구조화된 데이터들의 모임

---
#### 데이터들의 저장 과정
1. MM로 Block단위의 데이터 이동
2. Block 사본을 갱신
3. Block Storage 내 저장위치에 Block 사본을 저장
-> 블록 읽기 시간 + 블록 갱신 시간 + 블록 사본 저장 시간 = 총 데이터 저장 시간

---
#### 데이터들을 저장하는 방법 : Blocking ++
- Blocking : 대량의 Record로 구성된 파일 데이터의 효율적 입출력을 위해 몇 개의 Record로 나누어 저장하는 방식
- Blocking 인수 : floor(B/R) = BF(Blocking factor)

- *블로킹 종류* 
	- 고정 길이 블로킹 : 고정 길이 레코드를 블록에 저장 -> 저장공간에 빈 공간 발생
	- 신장 가변 길이 블로킹 : 가변 길이 레코드를 인접한 블록에 빈칸없이 저장 -> 빈 공간은 없지만, 레코드를 잘라서 두 블럭에 저장하기에 해당 레코드를 MM에 올릴때, 두 블럭을 모두 올려야 되는 문제 발생
	- 비신장 가변 길이 블로킹 : 가변 길이 레코드를 신장 가변 길이 블로킹처럼 자르지 않고 저장 -> 빈 공간 발생

**고정 길이 레코드 : 레코드가 필드의 데이터 형식에 맞춰 구조가 이루어진 레코드로, 빈 공간은 padding을 통해 빈틈 없이 차있다. (field가 130byte의 구조를 형성하면, record도 130byte)
가변 길이 레코드 : 레코드가 필드의 데이터 형식에 맞춰 구조가 이루어지지 않은 레코드로, 빈 공간이 존재해 메모리의 효율이 좋지만, 나중에 값이 들어올 경우 따로 동적 할당이 필요함.**

---
#### 프로그램을 통한 파일입출력 ++
- OS는 다양한 버전이 존재하고, 이에 따라 다양한 FS가 존재한다 -> 이를 VFS로 추상화하고, OS마다 Mapping하는 방식으로 사용

1. Program에서 OS에 System call, offset(저장공간주소), data을 보내면 
2. 여러 FS를 추상화시킨 VFS가 OS에 맞는 FS로 Mapping
3. FS가 Program에서 보낸 offset&data를 읽고 Block storage번호로 바꾼다.
4. OS에 Block Device Driver가 Block storage번호를 받고, I/O controller에게 해당 번호에 접근해 data를 가져오도록 명령
5. I/O controller가 접근해 데이터를 읽고, MM에 데이터 전송

---
#### 파일 내 레코드 구성 ++
- 레코드 저장 방식(Blocking)에 따른 파일
- 순차 파일 : 검색 key값에 따라 순차적으로, 순서대로 저장
- 인덱스 파일 : key/record 위치 정보를 인덱스로 저장
- 직접 파일 : 임의 레코드의 key 값으로 그 레코드를 직접 접근

---
#### 순차파일 ++
- 검색 키로 정렬된 record들을 pointer chain으로 연결
- 검색 키(search key) : 찾는 기준이 되는 필드

1. 데이터 삽입 : pointer chain으로 이루어지며, 삽입이 이루어지고, 앞뒤 레코드와 pointer chain을 통해 연결됨(pointer chain은 record 내부에 존재), 여유공간이 없을 경우(남은 블록 공간보다 record의 크기가 더 클때) Overflow Block에 record를 삽입하게 된다.
2. 삭제 : 삽입과 마찬가지로 pointer chain으로 이루어지며, 
3. 정렬
	- 내부정렬 :
	- 외부정렬 :
4. 합병 :

- RUN 생성 방법

---
#### 인덱스 파일 ++

---
#### 직접 파일 