# 데이터의 저장
- 데이터가 물리적으로 저장되는 단위는 *Block*이지만, *Block*으로 단위화 할경우, 프로그램당 관리해야할 Block이 수없이 많아짐 -> *File*이라는 논리적 개념이 탄생

#### 파일
- 정의 : 컴퓨터의 저장장치에 데이터를 저장하는 논리적인 단위
- 목적 
	1. 프로그램과 별도로 저장하여 독립성 유지
	2. MM(Main Memory)에 효율적으로 활용
	3. 여러 프로그램 공유

---
#### 파일시스템
- 배경 : OS에서 논리적인 데이터 단위인 파일을 Memory간 효율적으로 관리하기 위해 파일시스템 탄생
- 정의 : OS가 Block 단위의 데이터들을 현실 개념 단위인 파일에 맞추어 관리하기 위한 체계
- 일반적으로 데이터를 파일로 저장하기 위해 유사한/형태가 동일한 데이터들의 집합(구조화된 데이터)로 저장

---
#### Record Type
- field : 논리적 데이터의 최소 단위
- Record : field에 맞춰 구조화된 데이터들의 모임

---
#### 데이터들의 저장 과정
1. MM로 Block단위의 데이터 이동
2. Block 사본을 갱신
3. Block Storage 내 저장위치에 Block 사본을 저장
-> 블록 읽기 시간 + 블록 갱신 시간 + 블록 사본 저장 시간 = 총 데이터 저장 시간

---
#### 데이터들을 저장하는 방법 : Blocking ++
- Blocking : 대량의 Record로 구성된 파일 데이터의 효율적 입출력을 위해 몇 개의 Record로 나누어 저장하는 방식
- Blocking 인수 : floor(B/R) = BF(Blocking factor)

- *블로킹 종류* 
	- 고정 길이 블로킹 : 고정 길이 레코드를 블록에 저장 -> 저장공간에 빈 공간 발생
	- 신장 가변 길이 블로킹 : 가변 길이 레코드를 인접한 블록에 빈칸없이 저장 -> 빈 공간은 없지만, 레코드를 잘라서 두 블럭에 저장하기에 해당 레코드를 MM에 올릴때, 두 블럭을 모두 올려야 되는 문제 발생
	- 비신장 가변 길이 블로킹 : 가변 길이 레코드를 신장 가변 길이 블로킹처럼 자르지 않고 저장 -> 빈 공간 발생

**고정 길이 레코드 : 레코드가 필드의 데이터 형식에 맞춰 구조가 이루어진 레코드로, 빈 공간은 padding을 통해 빈틈 없이 차있다. (field가 130byte의 구조를 형성하면, record도 130byte)
가변 길이 레코드 : 레코드가 필드의 데이터 형식에 맞춰 구조가 이루어지지 않은 레코드로, 빈 공간이 존재해 메모리의 효율이 좋지만, 나중에 값이 들어올 경우 따로 동적 할당이 필요함.**

---
#### 프로그램을 통한 파일입출력 ++
- OS는 다양한 버전이 존재하고, 이에 따라 다양한 FS가 존재한다 -> 이를 VFS로 추상화하고, OS마다 Mapping하는 방식으로 사용

1. Program에서 OS에 System call, offset(저장공간주소), data을 보내면 
2. 여러 FS를 추상화시킨 VFS가 OS에 맞는 FS로 Mapping
3. FS가 Program에서 보낸 offset&data를 읽고 Block storage번호로 바꾼다.
4. OS에 Block Device Driver가 Block storage번호를 받고, I/O controller에게 해당 번호에 접근해 data를 가져오도록 명령
5. I/O controller가 접근해 데이터를 읽고, MM에 데이터 전송

---
#### 파일 내 레코드 구성 ++
- 레코드 저장 방식(Blocking)에 따른 파일
- 순차 파일 : 검색 key값에 따라 순차적으로, 순서대로 저장
- 인덱스 파일 : key/record 위치 정보를 인덱스로 저장
- 직접 파일 : 임의 레코드의 key 값으로 그 레코드를 직접 접근

---
#### 순차파일 ++
- 검색 키로 정렬된 record들을 pointer chain으로 연결
- 검색 키(search key) : 찾는 기준이 되는 필드

1. 데이터 삽입 : pointer chain으로 이루어지며, 삽입이 이루어지고, 앞뒤 레코드와 pointer chain을 통해 연결됨(pointer chain은 record 내부에 존재), 여유공간이 없을 경우(남은 블록 공간보다 record의 크기가 더 클때) Overflow Block에 record를 삽입하게 된다.
	- Overflow Block : primary block(현재 사용중인 정규 Block)에 공간이 다 차면 추가적으로 block을 할당하고, 이를 overflow Block이라고 한다.
2. 삭제 : 삽입과 마찬가지로 pointer chain으로 이루어진다.
3. 정렬 : 검색 키의 순서대로 record들을 정렬
	- 내부정렬 : 정렬할 데이터가 MM보다 크기가 작을 때, MM에 모두 가져와 정렬
	- 외부정렬 : 정렬할 데이터가 MM보다 크기가 클 경우, 데이터를 쪼개 정렬 후 합병
		- Subfile : 쪼개진 데이터
		- Run : 정렬된 쪼개진 데이터
4. 합병 : 외부정렬시 Run들을 합쳐 원하는 결과값을 생성

- RUN 생성 방법
	- 전체 Record = Run의 수 * Run당 레코드의 수, 즉 Run의 수가 많아질수록 합병과정이 복잡해짐.
	1. 내부정렬 : 파일을 n개씩 짤라 내부 정렬로 정렬 -> 모든 Run의 길이가 동일하여 합병 알고리즘 간단
	2. 대체선택 : 파일 내 데이터를 MM의 크기만큼 순차적으로 가져와 m개 유지, Run에 조건에 맞는 값들을 채워나가는데, 이때 MM의 가장 작은 값이 Run에 못들어갈 경우 freeze(값 고정) -> 평균적으로 내부정렬보다 긴 Run의 길이, 합병 비용이 적지만, Run의 길이가 일정하지 않아 합병 알고리즘 복잡
	3. 자연선택 : 대체선택과 유사한 방법이지만, MM에서 freeze된 데이터를 저장하는 m' 크기의 파일이 존재, MM과 해당 파일 내 모든 데이터가 freeze일 경우 Run생산 종료 -> Run당 record가 가장 많아 메모리적 효율적이지만, 긴 Run을 통해 얻는 이득과 저장소 입출력 비용을 비교해야할 필요 존재

- 합병 방식
	1. M-Way 합병 : M개의 Run을 통해 1개의 Run을 생성, 이때 M은 한 번에 합병할 수 있는 Run의 개수를 뜻함 -> M개씩 합쳐서 최종적으로 1개의 Run으로 합병 (승자 트리, 패자 트리)
	2. 균형 합병 : M-way합병에서 중간차수 결과물을 다시 분배하는 것을 제거
	원래 M-Way합병의 방식은 12개의 Run이 존재할 때, 이를 2-Way방식으로 합병시에 (1,2),(3,4)...이런식으로 6개의 Run으로 합병이 이루어지고, 6개의 Run을 다시 입력 파일로 분배하는 과정을 거침 -> 

---
#### 인덱스 파일 ++

---
#### 직접 파일 