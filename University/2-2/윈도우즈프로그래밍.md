
# W1

Windows라는 OS를 확인하고, OS가 어떤 식으로 동작하는지 확인.

kernel, shell, GDI(GPU 연동 소켓 느낌)의 3종류를 통해 I/O이벤트 식별.

#### function prototype
c/cpp는 절차 지향 프로그래밍 언어로, 함수 호출 구문이 작성되었을때, 해당 함수가 이전에 정의/선언이 되어 있지 않은 상태이면 컴파일 오류가 발생한다.

#### function 종류
1. 사용자정의 함수 : 카멜케이스 or 스네이크케이스
2. 라이브러리 함수 : 카멜케이스 + 소문자only
	- c/cpp : sprintf, scanf 등 
	- API : CreateWindow() 등
3. 메크로 함수 : 모두 대문자

#### 문자집합(아스키코드 vs 유니코드)
- 아스키코드(A) : 한글은 2byte, 영문, 특수문자 같은 글자는 1byte로 치환됨
- 유니코드(W)  : 모든 글자가 2byte의 형식을 띔.

아스키코드는 비교적 적은 용량을 차지하지만, 디코딩에 시간이 보다 소요될 수 있다.
유니코드는 반대.

char은 아스키코드이지만, wchar은 유니코드로 작성됨.(W 붙어있으면 다 유니코드의 wide)
한글을 변수로 표현하고 싶은 경우 wchar을 사용해야 추후에 컴파일 후 한글이 깨지는 것을 방지할 수 있다.


# W2

## Step 3

#### window 등록 단계
1. wWinMain실행
2. MyRegisterClass를 통해 Window에 필요한 자원들에 대한 구조체 생성 및 등록
3. InitInstance를 통해 window 생성 *(구조체로 등록한 szWindowClass랑 생성시 등록할 szWindowClass가 다를 경우 nullptr을 반환하여 창 생성이 안됨)*
4. 무한 반복문을 통해 Message루프 돌기
5. 보낸 메세지들은 2번에서 등록한 구조체의 WndProc로 날라가 메세지 처리 함수 수행.
6. WM_QUIT == FALSE일 경우, 즉 위 Message가 False가 나올 경우 종료

---

#### wcex 구조체 내부 변수
- 


---
- <window.h>를 통해 사용자 구조체의 대부분이 정의되어 있다. -> "framwork.h"대신 이것만 사용해도 됨
- 리소스 파일 : 아이콘, 문자열 등 다양한 자원들을 모아놓음 -> "resource.h"와 연동되어 있다.
- lpsz : long pointer string zero, 문자열 포인터
- 문자열을 그냥 쓰게 되면 아스키코드로 인식되므로 앞에 L을 붙인다 -> L"test" 이런식으로 넣으면 wchar과 같은 유니코드 문자 타입에 초기화 가능(TEXT("test")도 가능)
- 도구-spy++을 통해 log message 확인
- ShowWindow 함수에 SIZE_MAXSHOW를 넣으면 창을 최대 크기로 생성

# W3

## step 6

WndProc 함수는 os의 메시지를 받아 switch문을 통해 해당 case에 맞는 이벤트를 발생시킨다.
#### Window 내부 그리기 추가(WndProc - WM_PAINT case)
- hdc : handle to device context로, window를 포인터로 가르켜 context뿐만 아니라 rectangle과 같은 도형도 그려짐
- RECT : 사각형 구조체 (x1,y1, x2,y2)로 초기화
- Rectangle(hdc, rt.left, rt.top, rt.right, rt.bottom) : 사각형 그리기
- Ellipse(hdc, rt.left, rt.top, rt.right, rt.bottom) : 위 Rectangle 사각형에 내접하는 타원 그리기
*GetClientRect()를 통해 RECT 구조체를 초기화 할 경우, window 크기를 조절때마다 사각형과 타원의 크기를 조절할 수 있다.*
- TextOut(hdc, int x, int y, TEXT(text), int textlength) : textlength만큼 (x,y)위치에 text를 나타냄
*textlength랑 text랑 길이가 다를 경우 짤려서 출력되거나, 뒤에 이상한 값들도 초기화되서 출력될 수 있다.*
- SetTextColor(hdc, RGB(a,b,c)) : hdc가 가르키는 window의 글자 색, 바뀌기 전에는 적용이 안된다.
- SetBkColor(hdc, RGB(a,b,c)) : hdc가 가르키는 window의 배경 색, 다음 TextOut의 뒷 블럭만 칠해진다.
- SetTextAlign(hdc, TA_Bottom | TA_Top | TA_Right | TA_Left) : TextOut의 context블럭의 어느 점을 기준으로 context를 출력할 것인지 세팅. (기본적으로 좌측 상단이 기준이고, TA_Bottom | TA_Right하면 아래 | 오른쪽 이므로 우측 하단 꼭짓점을 100,100에 출력한다는 의미이다.)
- DrawText(hdc, TEXT("text"), -1, &RECT, DT_LEFT | DT_RIGHT | DT_TOP | DT_BOTTOM | DT_CENTER | DT_VCENTER | DT_SINGLELINE) : 사각형 구조체 RECT에 TEXT context를 생성한다.
- GetClientRect(hWnd, &rt) : 초기에 window 생성하면서 정한 hWnd(윈도우 창의 크기)를 rt에 초기화
- SetPixel(hdc, x, y, RGB) : (x,y) pixel을 RGB색상으로 변경, 이중 for문으로 모든 window를 칠할 수 있다.
- MoveToEx(hdc, x, y, NULL) : hdc가 window에서 가르키는 픽셀을 x,y로 움직인다.
- LineTo(hdc, x, y) : hdc를 x,y로 움직이면서 직선을 그린다.
## step 8
#### Window 생성 시 (WndProc - WM_CREATE case)
- InitInstance 함수를 보면 hWnd는 CreateWindowW를 통해 window를 생성하고, 해당 구조체를 hWnd에 저장하는 것을 보여준다. 이때 Create했다는 message가 발생하는데, 이를 WM_CREATE라고 한다.
- 따라서 위 WM_CREATE message를 handling하여 switch문에 case로 추가한 후 사용 시 CreateWindowW와 함께 해당 case가 실행
- CreateFont : 폰트 생성
- CreatePen(PS_DASH, 1, RGB) : 펜 생성
- CreateSolidBrush()
- CreateHatchBrush()
- SetDCPenColor()
- SetDCBrushColor()
- FillRect()

생성시 한 번만 생성되는게 좋기 때문데 WM_CREATE case에 넣어 window Create Message에 반응하여 만들어 지도록 만든다.

---

- SelectObject(hdc, 구조체) : hdc 내부의 변수를 구조체로 바꾼다는 의미인데, HFONT로 예를 들자면
```cpp
case WM_CREATE:
{
    hFont = CreateFont(100, 0, 0, 0, FW_BOLD, 0, 0, 0, HANGEUL_CHARSET, 0, 0, 0, 0, _T("명조"));
    break;
}

case WM_PAINT:
{
	HFONT hOldFont = (HFONT)SelectObject(hdc, hFont);//반환값으로 전에 사용하던 font가 튀어나옴
	TextOut(hdc, 100, 100, _T("안녕"), 2);//hFont로 작성
	
	SelectObject(hdc, hOldFont);
	TextOut(hdc, 100, 100, _T("Hello"), 5);//default font=hOldFont로 작성
}
```
즉, SelectObject는 hdc 구조체의 붓을 바꿔주고, 해당 붓을 반환해준다.

- GetStockObject

---
#### hRGN
다양한 모형들을 핸들링하는데 사용되는 GDI 객체
- CreateRectRgn(&rt) : 사각형 영역 생성
- CreateEllipticRgn(&rt) : 타원 영역 생성
- CreatePolygonRgn(Points[], anglecount, ALTERNATE) : 다각형 영역 생성 
- FillRgn(hdc, hRgn, hBrush) : hRgn영역을 hBrush로 칠하기
# W4

## step 9
#### Keyboard Event (WndProc - WM_KEYDONW case)
키보드 이벤트는 WndProc의 wParam을 통해 입력을 받고, IParam을 통해 누른 횟수를 입력 받는다. 

- WS_POPUP
- 

## step 10
## step 11

# W5

## step 12
## step 13
## step 14

