
같은 타입의 데이터를 연속된 메모리에 저장하는 방식이다.

구조적으로 간단하고 가장 먼저 접하는 자료구조인 만큼 꽤나 유용한 자료구조이다.

특히 연속된 메모리에 같은 타입의 데이터를 저장하는 방식은 각 데이터의 인덱스를 매기기 때문에 접근이 간편하다는 점을 장점으로 꼽을 수 있다.

---
#### 특징

1. 고정 크기 : 선언과 동시에 사용할 수 있는 메모리의 크기가 제한된다. 이는 장단점을 모두 갖고있다.
2. 빠른 임의 접근 : 앞서 말한 것처럼 인덱스를 통한 데이터 접근이 가능하기에 상수시간의 시간복잡도를 갖고 접근이 가능하다는 점이다. 물론 이는 이론적인 점에서 상수시간만큼 걸린다는 것이다.
3. 연속된 메모리 사용 : 메모리 사용이 연속적으로 이루어져 캐시 효율성이 좋다.
4. 삽입/삭제의 비효율성 : 삽입/삭제 시 데이터를 이동해야하므로 O(n)의 시간복잡도를 갖을 수 있다.

---
#### 시간복잡도

|         *연산/알고리즘*         |     **시간 복잡도**      |                         **설명**                          |
| :-----------------------: | :-----------------: | :-----------------------------------------------------: |
| **임의 접근 (Random Access)** |        O(1)         |                인덱스를 사용해 특정 요소에 바로 접근 가능.                |
| **선형 탐색 (Linear Search)** |        O(n)         |                 배열의 처음부터 끝까지 순차적으로 검색.                  |
| **이진 탐색 (Binary Search)** |      O(log n)       |                   배열이 정렬된 경우에만 사용 가능.                   |
|      **삽입 (중간에 삽입)**      |        O(n)         |                삽입 위치 이후의 모든 요소를 이동해야 함.                 |
|      **삽입 (끝에 삽입)**       | O(1) (고정 크기) / O(n) |      고정 크기 배열에서 끝 삽입은 상수 시간. 동적 배열은 크기 증가 시 복사 발생.      |
|     **삭제 (중간에서 삭제)**      |        O(n)         |                삭제된 요소 이후의 모든 요소를 이동해야 함.                |
|      **삭제 (끝에서 삭제)**      |        O(1)         |                배열의 끝 요소를 제거하는 것은 상수 시간.                 |
|     **정렬 (Sorting)**      |     O(n log n)      | 퀵 정렬(Quick Sort) 또는 병합 정렬(Merge Sort)과 같은 효율적인 알고리즘 사용. |
|      **회전 (Rotate)**      |        O(n)         |                   배열 요소를 특정 방향으로 이동.                    |
|      **합병 (Merge)**       |      O(n + m)       |                   두 개의 정렬된 배열을 합칠 때.                    |
|   **부분합 (Prefix Sum)**    |        O(n)         |               배열의 부분합을 계산하여 빠르게 구할 수 있음.                |

접근이 상수시간으로 매우 짧은 시간이 소요된다. 이는 크나큰 장접이기에 추가/삭제/변경 등이 필요하지 않는 데이터의 집합은 배열로 표기하게 되면 접근이 용이하다는 것을 알 수 있다.

#### 응용
---
- 달팽이배열
- Lookup배열

#### 추가사항
---
- 배열은 인덱스를 지정해 연속된 메모리에 데이터를 저장하고, 접근이 용이하게 된다. 따라서 주솟값 + (index * 자료형)의 과정을 거치면 쉽게 데이터를 찾는 것이 가능한다. 하지만 이론적인 부분에서 상수시간일뿐 실제로는 O(1)~O(n)까지 걸릴 수 있다. 그 이유는 3가지 인데 다음과 같다.

1. 메모리 캐시 미스
2. 페이지 폴트
3. TLB 미스

cpu는 데이터를 처리할 때 캐시메모리를 사용한다. 하지만 캐시 메모리도 한정적인 자원이고 특히 L1~L3까지 나누어진 캐시메모리는 용량이 매우 작다. 따라서 L1캐시 메모리보다 더 큰 배열의 값을 선언하게 되면 L1캐시메모리에 선언이 된 후 아직 선언되지 못한 나머지 데이터들은 L2캐시메모리에 이어서 선언이 되는데 이를 *승격(promotion)* 이라고 한다. 배열이 L1캐시메모리에 존재한다 인식을 하고 원소를 찾는데, 데이터가 L2캐시메모리에 존재하여 찾는데 시간이 많이 걸리는 경우가 발생하고, 이를 *캐시 미스(cache miss)* 라고 한다.

cpu에 물리적으로 존재하는 캐시 메모리와 다르게 실제 메모리보다 더 큰 메모리를 사용하는 것처럼 다루기 위해 운영체제가 가상 주소와 실제 물리 주소를 매핑하는 가상 메모리가 있다. 가상메모리의 메모리 공간을 다루는 단위가 바로 *페이지(page)* 라는 것이다. 




